<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cube + Bento with Inverse Bevel Cards</title>
<style>
  :root{
    --bg:#071425;
    --panel:rgba(255,255,255,0.03);
    --muted:rgba(190,215,240,0.7);
    --accent:#2f9bd8;
    --cube-size:240px;   /* visual size of cube's circular footprint */
    --bite-radius:60px;  /* radius of the inverse bevel (bite) applied to cards when they get close) */
  }

  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:#e6eef6;
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* Page layout */
  .wrap{
    min-height:100vh;
    display:grid;
    grid-template-columns: 1fr 520px 1fr;
    grid-template-rows: auto 520px auto;
    gap:28px;
    align-items:center;
    padding:36px;
    box-sizing:border-box;
  }

  .title-panel{
    grid-column:1; grid-row:1; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    padding:18px; border-radius:12px; max-width:520px;
  }
  .title-panel h1{font-size:26px;margin:0 0 8px 0}
  .title-panel p{margin:0;color:var(--muted)}

  .image-panel{
    grid-column:3; grid-row:1; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    border-radius:12px;padding:12px;height:120px;display:flex;align-items:center;justify-content:center;
    color:var(--muted);
  }

  .description-panel{
    grid-column:1; grid-row:2; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    padding:14px;border-radius:12px;max-width:520px;min-height:120px;
  }

  /* Cube center */
  .cube-container{grid-column:2;grid-row:2;position:relative;display:flex;align-items:center;justify-content:center}
  .scene{
    width:520px;height:520px;position:relative;perspective:1100px;touch-action:none;user-select:none;
    display:flex;align-items:center;justify-content:center;
  }

  /* Visual circular footprint that cards will "bite" into (placed above cards, below cube) */
  .circle-footprint{
    position:absolute;
    width:var(--cube-size);
    height:var(--cube-size);
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    border-radius:50%;
    pointer-events:none;
    /* subtle outline to help visualize - remove or reduce opacity in production */
    box-shadow: 0 0 0 6px rgba(47,155,216,0.03), 0 6px 24px rgba(2,6,23,0.6);
    z-index:2; /* sits above cards but below cube */
  }

  /* Cube (CSS 3D simplified) */
  .cube{
    width:var(--cube-size);
    height:var(--cube-size);
    position:relative;
    transform-style:preserve-3d;
    transform: translateZ(-120px) rotateX(-8deg) rotateY(0deg);
    z-index:3; /* above footprint & cards */
  }
  .cube .panel{
    position:absolute; inset:0; border-radius:10px; display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    backface-visibility:hidden;
    cursor:pointer;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  /* For demo we map faces simply using rotateY transforms (visual only) */
  .cube .front { transform: rotateY(0deg) translateZ(calc(var(--cube-size)/2)); }
  .cube .right { transform: rotateY(90deg) translateZ(calc(var(--cube-size)/2)); }
  .cube .back  { transform: rotateY(180deg) translateZ(calc(var(--cube-size)/2)); }
  .cube .left  { transform: rotateY(-90deg) translateZ(calc(var(--cube-size)/2)); }
  .cube .top   { transform: rotateX(90deg) translateZ(calc(var(--cube-size)/2)); }
  .cube .bottom{ transform: rotateX(-90deg) translateZ(calc(var(--cube-size)/2)); }

  .cube h3{margin:0 0 6px 0}
  .cube p{margin:0;color:var(--muted)}

  /* Bento grid sits under the footprint visually; cards will be given a 'bite' using a pseudo-element that matches page background */
  .bento {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:1; /* behind footprint and cube, so footprint/cube cover it */
    pointer-events:none; /* cards will enable pointer-events on themselves */
  }

  .bento-grid{
    width:760px;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    grid-auto-rows:120px;
    gap:18px;
    pointer-events:auto; /* enable interactions for cards themselves */
  }

  .card{
    position:relative;
    width:100%;
    height:100%;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    padding:12px;
    display:flex;
    gap:10px;
    align-items:center;
    cursor:pointer;
    overflow:visible; /* so bite pseudo-element can overlap */
    transition:transform .22s ease,box-shadow .22s ease;
    box-sizing:border-box;
  }
  .card:hover{ transform:translateY(-6px); box-shadow:0 14px 30px rgba(2,6,23,0.6); }

  .card .thumb{ width:84px; height:72px; border-radius:8px; background:linear-gradient(180deg,#0c1220,#081018); display:flex;align-items:center;justify-content:center;color:var(--muted); font-weight:700; flex:0 0 84px }
  .card .body h4{margin:0;font-size:14px}
  .card .body p{margin:6px 0 0 0;font-size:12px;color:var(--muted)}

  /* Inverse-bevel 'bite' pseudo-element:
     - It paints a circle of page background on top of the card, positioned where the card would intersect the circular footprint.
     - We compute the position with CSS variables set by JS: --bite-x, --bite-y in px relative to card's box (left/top).
     - When not needed we set --bite-alpha to 0.
  */
  .card::after{
    content:'';
    position:absolute;
    width:calc(var(--bite-radius)*2);
    height:calc(var(--bite-radius)*2);
    left:var(--bite-x, -9999px);
    top:var(--bite-y, -9999px);
    transform:translate(-50%,-50%);
    border-radius:50%;
    background:var(--bg, #071425);
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset;
    pointer-events:none;
    transition:left .12s linear, top .12s linear, opacity .18s linear, transform .12s linear;
    opacity: var(--bite-alpha, 0);
    z-index:4;
  }

  /* subtle stroke around the bite so it reads as a carved corner (optional) */
  .card::before{
    content:'';
    position:absolute;
    width:calc((var(--bite-radius)*2) + 2px);
    height:calc((var(--bite-radius)*2) + 2px);
    left:var(--bite-x, -9999px);
    top:var(--bite-y, -9999px);
    transform:translate(-50%,-50%);
    border-radius:50%;
    pointer-events:none;
    z-index:3;
    opacity: calc(var(--bite-alpha, 0) * 0.85);
    background:transparent;
    box-shadow: 0 6px 18px rgba(2,6,23,0.65) inset;
    transition:left .12s linear, top .12s linear, opacity .18s linear;
  }

  /* Project list & controls under the cube */
  .project-list{grid-column:2;grid-row:3;display:flex;flex-direction:column;gap:8px;max-width:760px;align-items:center}
  .project-list .header{width:100%;display:flex;justify-content:space-between;align-items:center}
  .project-list .expander{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;cursor:pointer}
  .project-list ul{list-style:none;width:100%;margin-top:8px;max-height:0;overflow:hidden;transition:max-height .36s ease}
  .project-list ul.open{max-height:300px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
  .project-list li{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);display:flex;justify-content:space-between;gap:12px}

  .hint{position:fixed;left:18px;bottom:18px;font-size:13px;color:var(--muted)}
  @media (max-width:980px){
    .wrap{grid-template-columns:1fr;grid-template-rows:auto auto auto;padding:20px;gap:18px}
    .cube-container{grid-column:1;grid-row:2}
    .title-panel{grid-column:1;grid-row:1}
    .image-panel{display:none}
    .description-panel{grid-column:1;grid-row:3}
    .project-list{grid-column:1;grid-row:4}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title-panel" id="titlePanel">
      <h1 id="projTitle">Minesweeper</h1>
      <p id="projSubtitle">Interactive tile-based puzzle</p>
    </div>

    <div class="image-panel" id="imagePanel">Image preview (shows the most visible face)</div>

    <div class="description-panel" id="descPanel">
      <p id="projDesc">Click or drag the cube. Cards show an inverse-bevel (curved bite) when they get close to the cube footprint.</p>
    </div>

    <div class="cube-container">
      <div class="scene" id="scene" aria-label="3D cube scene">
        <!-- cards layer (underneath footprint & cube) -->
        <div class="bento" id="bento">
          <div class="bento-grid" id="bentoGrid"></div>
        </div>

        <!-- circular footprint that takes visual priority over cards (cards will show a bite when intersecting) -->
        <div class="circle-footprint" id="footprint" aria-hidden="true"></div>

        <!-- cube (visual centerpiece) -->
        <div class="cube" id="cube" aria-hidden="false">
          <div class="panel front" data-slot="front" data-index="0">
            <h3>Project 1</h3><p>Project 1 subtitle</p>
          </div>
          <div class="panel right" data-slot="right" data-index="1">
            <h3>Project 2</h3><p>Project 2 subtitle</p>
          </div>
          <div class="panel back" data-slot="back" data-index="2">
            <h3>Project 3</h3><p>Project 3 subtitle</p>
          </div>
          <div class="panel left" data-slot="left" data-index="3">
            <h3>Project 4</h3><p>Project 4 subtitle</p>
          </div>
        </div>
      </div>
    </div>

    <div class="project-list">
      <div class="header">
        <div style="font-weight:700">Projects</div>
        <div class="expander" id="expander">Expand</div>
      </div>
      <ul id="projectListUl"></ul>
    </div>
  </div>

  <div class="hint">Drag to rotate â€¢ Cards get a circular bevel where they meet the cube</div>

<script>
/* JS responsibilities:
 - create bento grid cards
 - compute card center positions relative to circular footprint center
 - if card's corner would overlap the circular footprint, position the card's ::after bite to match intersection (using CSS variables)
 - simple cube horizontal drag rotation (cumulative-drag model)
 - update "most visible face" (approximate using angle) and feed title/desc panels
 - clicking a card centers the cube on that project's nearest horizontal slot
*/

const projects = [
  { title:'Minesweeper', subtitle:'Interactive tile-based puzzle', desc:'Classic minesweeper with modern UI', url:'/PolyWeave-Mines/', color:'#e74c3c' },
  { title:'Project 2', subtitle:'Utility tool', desc:'Small utility app demo', url:'#', color:'#27ae60' },
  { title:'Project 3', subtitle:'Algorithmic art', desc:'Generative visuals', url:'#', color:'#9b59b6' },
  { title:'Project 4', subtitle:'UX experiments', desc:'Micro interaction set', url:'#', color:'#1abc9c' },
  { title:'Project 5', subtitle:'Extra', desc:'Extra project', url:'#', color:'#f39c12' },
  { title:'Project 6', subtitle:'Extra 2', desc:'Extra project 2', url:'#', color:'#34495e' }
];

const bentoGrid = document.getElementById('bentoGrid');
const footprint = document.getElementById('footprint');
const scene = document.getElementById('scene');
const cube = document.getElementById('cube');
const projTitle = document.getElementById('projTitle');
const projSubtitle = document.getElementById('projSubtitle');
const projDesc = document.getElementById('projDesc');
const imagePanel = document.getElementById('imagePanel');
const projectListUl = document.getElementById('projectListUl');
const expander = document.getElementById('expander');

const FOOTPRINT_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cube-size')) || 240;
const BITE_RADIUS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bite-radius')) || 60;

// Build a 3x3 grid of cards, leaving center transparent (so cube sits visually above)
function buildBento(){
  bentoGrid.innerHTML = '';
  const cells = 9;
  for(let cell=0; cell<cells; cell++){
    if(cell===4){
      // center spacer
      const spacer = document.createElement('div');
      spacer.style.width='100%'; spacer.style.height='100%'; spacer.style.background='transparent';
      bentoGrid.appendChild(spacer);
      continue;
    }
    const projectIndex = (cell- (cell>4?1:0)) % projects.length; // simple assignment so cards show projects in sequence
    const p = projects[projectIndex];
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.proj = projectIndex;
    card.innerHTML = `<div class="thumb">#${projectIndex+1}</div><div class="body"><h4>${p.title}</h4><p>${p.subtitle}</p></div>`;
    bentoGrid.appendChild(card);

    card.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      // center cube on this project's logical slot (simple mapping)
      centerCubeOnProject(projectIndex);
    });
  }
}
buildBento();

// Build project list
function buildProjectList(){
  projectListUl.innerHTML = '';
  projects.forEach((p,i)=>{
    const li = document.createElement('li');
    li.innerHTML = `<div>${i+1}. ${p.title}</div><div><button data-i="${i}">Open</button></div>`;
    projectListUl.appendChild(li);
    li.querySelector('button').addEventListener('click', ()=> window.open(p.url,'_blank'));
  });
}
buildProjectList();

// measure positions and update card bite locations.
// Idea: footprint is a circle centered in scene. For each card, compute the closest point from the card rectangle to the circle center.
// If distance from that closest point to circle center is less than (footprintRadius + margin), we place a bite circle on the card at that local position (relative to card).
// The bite pseudo element uses CSS variables --bite-x and --bite-y (px from card left/top) and --bite-alpha (0..1).
function updateCardBites(){
  const cards = Array.from(bentoGrid.querySelectorAll('.card'));
  const fpRect = footprint.getBoundingClientRect();
  const fpCenter = { x: fpRect.left + fpRect.width/2, y: fpRect.top + fpRect.height/2 };
  const fpRadius = Math.min(fpRect.width, fpRect.height)/2;

  cards.forEach(card=>{
    const rect = card.getBoundingClientRect();
    // find point on card rectangle closest to circle center
    const closestX = Math.max(rect.left, Math.min(fpCenter.x, rect.right));
    const closestY = Math.max(rect.top, Math.min(fpCenter.y, rect.bottom));
    const dx = closestX - fpCenter.x;
    const dy = closestY - fpCenter.y;
    const dist = Math.hypot(dx,dy);

    // if the closest point is inside the footprint + small margin, then we need a bite.
    const margin = 6; // small gap so bite sits comfortably
    if(dist < fpRadius + margin){
      // compute local coordinates inside card for the bite center
      const localX = closestX - rect.left;
      const localY = closestY - rect.top;
      // set CSS variables on the card
      card.style.setProperty('--bite-x', `${Math.round(localX)}px`);
      card.style.setProperty('--bite-y', `${Math.round(localY)}px`);
      card.style.setProperty('--bite-radius', `${BITE_RADIUS}px`);
      card.style.setProperty('--bite-alpha', '1');
    } else {
      // hide bite
      card.style.setProperty('--bite-alpha', '0');
      // push it off-screen to avoid visible edge cases
      card.style.setProperty('--bite-x', `-9999px`);
      card.style.setProperty('--bite-y', `-9999px`);
    }
  });
}

// Simple cube rotation (cumulative-drag model) + visibility heuristic for "most visible face"
// Rotation is in degrees around Y (rotY). frontIndex maps which project is at front slot (0..n)
let rotY = 0;
let isPointerDown = false, startX = 0, startRot = 0, startT = 0, angVel = 0;
const SENS = 0.35;
const CLICK_MOVE_THRESHOLD = 6;
const CLICK_TIME_THRESHOLD = 300;

scene.addEventListener('pointerdown', (e)=>{
  isPointerDown = true;
  startX = e.clientX;
  startRot = rotY;
  startT = performance.now();
  angVel = 0;
  scene.setPointerCapture(e.pointerId);
});
scene.addEventListener('pointermove', (e)=>{
  if(!isPointerDown) return;
  const dx = e.clientX - startX;
  const target = startRot + dx * SENS;
  angVel = target - rotY;
  rotY = target;
  applyCubeRotation();
});
scene.addEventListener('pointerup', (e)=>{
  scene.releasePointerCapture(e.pointerId);
  const dt = performance.now() - startT;
  const moved = Math.hypot(e.clientX - startX, e.clientY - startX);
  const isClick = moved <= CLICK_MOVE_THRESHOLD && dt <= CLICK_TIME_THRESHOLD;
  isPointerDown = false;
  // cap angular velocity
  angVel = Math.max(-20, Math.min(20, angVel));
  if(isClick){
    // click detection: element at point
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const face = el && el.closest && el.closest('.panel');
    if(face){
      // get project index from face's data-index
      const idx = Number(face.dataset.index);
      if(!Number.isNaN(idx) && projects[idx]) window.open(projects[idx].url,'_blank');
    }
  }
});

function applyCubeRotation(){
  cube.style.transform = `translateZ(-120px) rotateX(-8deg) rotateY(${rotY}deg)`;
  updateMostVisibleFace();
  // footprint/circle doesn't move but since cube rotates in place, card bites don't need to recalc by rotation (they're based on static layout)
  // update card bites in case of layout changes
  updateCardBites();
}

// Determine which horizontal face is most visible (approx by angle).
// We'll check 4 slots: front(0deg), right(-90), back(180), left(90) relative to cube's local coordinate. Use -rotY to compute visual offset.
// pick the slot with highest cos of the angle difference.
function updateMostVisibleFace(){
  const rad = (rotY * Math.PI)/180;
  const slotAngles = [0, -Math.PI/2, -Math.PI, Math.PI/2]; // front, right, back, left
  const scores = slotAngles.map(sa=>{
    const diff = normalizeAngleRad(-rad - sa);
    return Math.max(0, Math.cos(diff)); // negative -> 0
  });
  let best = 0, idx = 0;
  for(let i=0;i<scores.length;i++){
    if(scores[i] > best){ best = scores[i]; idx = i; }
  }
  // compute project index shown at that slot: we treat initial mapping as front->projects[0], right->projects[1], back->projects[2], left->projects[3]
  const projIndex = (idx) % projects.length;
  const p = projects[projIndex];
  if(p){
    projTitle.textContent = p.title;
    projSubtitle.textContent = p.subtitle;
    projDesc.textContent = p.desc;
    imagePanel.textContent = `${p.title} preview (no image)`; // placeholder
    imagePanel.style.borderLeft = `4px solid ${p.color}`;
  }
}

// helper: normalize angle rad to [-PI,PI)
function normalizeAngleRad(a){
  const two = Math.PI*2;
  let v = (a + Math.PI) % two;
  if(v < 0) v += two;
  return v - Math.PI;
}

// center cube on a project index (simple mapping by nearest horizontal slot)
function centerCubeOnProject(projIdx){
  // find which slot (0..3) this project should be in for the base sequence
  // Our simple mapping uses projIdx mod 4 -> slot 0..3
  const slot = projIdx % 4; // 0=front,1=right,2=back,3=left
  // desired rotation to bring that slot to front: rotate by -slot*90 degrees (nearest)
  const desiredRel = -slot * 90;
  const target = rotY + desiredRel;
  animateRotationTo(target, 420);
}

function animateRotationTo(targetDeg, duration=420){
  const start = performance.now();
  const from = rotY;
  function step(ts){
    const t = Math.min(1, (ts - start)/duration);
    const eased = 1 - Math.pow(1-t,3);
    rotY = from + (targetDeg - from) * eased;
    applyCubeRotation();
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// inertia animation loop (smooth spin after pointer release)
let lastT = performance.now();
function loop(now){
  const dt = (now - lastT)/1000; lastT = now;
  if(!isPointerDown && Math.abs(angVel) > 0.0005){
    rotY += angVel;
    angVel *= Math.pow(0.90, dt*60);
    applyCubeRotation();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Recompute card bites on resize / scroll and on initial layout
function recomputeAll(){
  // ensure footprint centered exactly where cube is rendered
  const sceneRect = scene.getBoundingClientRect();
  const centerX = sceneRect.left + sceneRect.width/2;
  const centerY = sceneRect.top + sceneRect.height/2;
  // footprint already visually centered with CSS, but ensure it is where we think
  updateCardBites();
  updateMostVisibleFace();
}
window.addEventListener('resize', recomputeAll);
window.addEventListener('load', ()=>{ recomputeAll(); setTimeout(recomputeAll,120); });

// simple expand/collapse list
let listOpen = false;
expander.addEventListener('click', ()=>{
  listOpen = !listOpen;
  const ul = projectListUl;
  if(listOpen){
    ul.classList.add('open');
    expander.textContent = 'Collapse';
  } else {
    ul.classList.remove('open');
    expander.textContent = 'Expand';
  }
});

// initial render
applyCubeRotation();
updateCardBites();
updateMostVisibleFace();

</script>
</body>
</html>
