<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Claw Machine — Projects</title>
  <style>
    :root{
      --bg:#0b1020; --card:#0f1724; --accent:#ffd166; --muted:#9aa4b2;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%,#0b1020 60%);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#e6eef6}
    .wrap{max-width:980px;margin:28px auto;padding:18px}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    #gameCard{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.04));border:1px solid rgba(255,255,255,0.04);border-radius:12px;padding:12px;display:grid;grid-template-columns:420px 1fr;gap:12px;align-items:start}
    canvas{width:100%;height:auto;background:transparent;border-radius:8px;display:block}
    .controls{display:flex;flex-direction:column;gap:10px;padding:6px}
    .row{display:flex;gap:8px;align-items:center}
    button, .btn{
      background:linear-gradient(180deg,#ffefbe,#ffd166);
      color:#111;border:0;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,0.35)
    }
    button[disabled]{opacity:.5;cursor:default}
    .meta{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;color:var(--muted);font-size:13px;min-height:120px}
    .projects-list{display:flex;flex-direction:column;gap:8px;max-height:320px;overflow:auto;padding-right:6px}
    .proj{display:flex;gap:10px;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
    .proj img{width:36px;height:36px;border-radius:6px;object-fit:cover;background:#223}
    .proj .txt{font-size:13px}
    .proj .title{font-weight:700;color:#fff}
    .proj .desc{color:var(--muted);font-size:12px}
    footer{margin-top:14px;color:var(--muted);font-size:12px}
    @media (max-width:900px){
      #gameCard{grid-template-columns:1fr;align-items:stretch}
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Claw machine demo">
    <header>
      <svg width="40" height="40" viewBox="0 0 24 24" aria-hidden focusable="false">
        <rect x="1" y="2" width="22" height="20" rx="4" fill="#ffd166"></rect>
        <circle cx="12" cy="12" r="5" fill="#0b1020"></circle>
      </svg>
      <div>
        <h1>Mini Claw Machine — Projects</h1>
        <p class="lead">Use the joystick or arrow keys to move the claw. Press Space or Tap the Grab button to attempt a pick.</p>
      </div>
    </header>

    <main id="gameCard">
      <div>
        <canvas id="gameCanvas" width="420" height="560" aria-label="Claw machine canvas"></canvas>
        <div style="display:flex;gap:10px;margin-top:8px;align-items:center">
          <div class="row" style="gap:6px;">
            <button id="leftBtn" aria-label="Move left">◀</button>
            <button id="downBtn" aria-label="Move down">▼</button>
            <button id="rightBtn" aria-label="Move right">▶</button>
          </div>
          <div style="flex:1"></div>
          <button id="grabBtn" class="btn" aria-label="Grab">Grab</button>
        </div>
      </div>

      <aside class="controls" aria-live="polite">
        <div class="row">
          <div class="meta" style="flex:1">
            <strong id="selectedTitle">Loading...</strong>
            <div id="selectedDesc" style="margin-top:6px;color:var(--muted);font-size:13px">Project details will appear here.</div>
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
            <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Available Prizes</div>
            <div class="projects-list" id="projectsList" role="list"></div>
          </div>
        </div>

        <div class="row">
          <div style="font-size:12px;color:var(--muted);flex:1">
            If projects fail to load, a fallback set will appear. Open console for load errors.
          </div>
          <button id="reloadBtn" title="Reload projects">Reload</button>
        </div>
      </aside>

    </main>

    <footer>
      Tip: hold arrow keys or use buttons. The demo is defensive: missing images, malformed JSON, or file:// fetch issues are handled gracefully.
    </footer>
  </div>

  <script>
  (function(){
    "use strict";

    /* ---------------------------
       Defensive defaults & config
       --------------------------- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = canvas.width * DPR;
    canvas.height = canvas.height * DPR;
    canvas.style.width = '420px';
    canvas.style.height = '560px';
    ctx.scale(DPR, DPR);

    // UI elements
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const downBtn = document.getElementById('downBtn');
    const grabBtn = document.getElementById('grabBtn');
    const reloadBtn = document.getElementById('reloadBtn');
    const projectsList = document.getElementById('projectsList');
    const selectedTitle = document.getElementById('selectedTitle');
    const selectedDesc = document.getElementById('selectedDesc');

    // Game area (logical coords)
    const W = 420, H = 560;
    const playX = 40, playY = 80, playW = 340, playH = 420;

    // State
    let projects = null;
    let imagesByUrl = new Map(); // cache successful images
    let defaultFaviconDataUrl = null;
    let animationId = null;
    let lastTime = 0;

    // Claw parameters
    const claw = {
      x: playX + playW / 2,
      y: playY - 10,
      width: 48,
      height: 24,
      armLength: 80,
      targetX: null,
      targetY: null,
      vx: 0,
      speed: 160, // px/s horizontal
      state: 'idle', // idle, moving, lowering, grabbing, lifting, dropping
      grabTimer: 0,
      hold: null, // index of capsule held
      lockInput: false
    };

    // Capsules pool
    let capsules = []; // {x,y,r,projectIndex,vy,grabbed}
    const MAX_CAPSULES = 9;

    // Input
    const input = { left:false, right:false, down:false, grab:false };

    // Timeouts & resource trackers
    const timers = new Set();

    /* ---------------------------
       Utility helpers
       --------------------------- */
    function safeParseJSON(text){
      try{
        return JSON.parse(text);
      }catch(e){
        console.warn('projects.json parse failed:', e);
        return null;
      }
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function rand(min,max){return Math.random()*(max-min)+min;}

    function scheduleTimeout(fn, ms){
      const id = setTimeout(()=>{ timers.delete(id); fn(); }, ms);
      timers.add(id);
      return id;
    }
    function clearAllTimers(){
      for(const id of Array.from(timers)){ clearTimeout(id); timers.delete(id); }
    }

    /* ---------------------------
       Fallback projects (defensive)
       --------------------------- */
    const FALLBACK_PROJECTS = [
      { title: "Arcade Portfolio", name: "arcade", description: "A playful portfolio with cabinet metaphors.", favicon: "" },
      { title: "Capsule UI", name: "capsule-ui", description: "Micro-interactions collected into capsules.", favicon: "" },
      { title: "Infinite Hallways", name: "hallways", description: "Trippy geometry experiments and demos.", favicon: "" }
    ];

    /* ---------------------------
       Projects loading
       --------------------------- */
    async function loadProjects(){
      // Reset current state
      projects = null;
      projectsList.innerHTML = '';
      selectedTitle.textContent = 'Loading...';
      selectedDesc.textContent = '';

      // Try fetch
      try {
        const res = await fetch('projects.json', {cache: "no-store"});
        if(!res.ok) throw new Error('HTTP ' + res.status);
        const txt = await res.text();
        const parsed = safeParseJSON(txt);
        if(!parsed || !Array.isArray(parsed)){
          throw new Error('Invalid JSON structure: expected array');
        }
        projects = parsed.map((p, i) => sanitizeProject(p, i));
      } catch (err) {
        // Common failure mode: file:// CORS or local open; fallback to embedded list
        console.warn('Failed to load projects.json — falling back. Error:', err);
        projects = FALLBACK_PROJECTS.map((p,i)=>sanitizeProject(p,i));
      }

      // Ensure at least one project
      if(projects.length === 0){
        projects = FALLBACK_PROJECTS.map((p,i)=>sanitizeProject(p,i));
      }

      // Preload favicon images defensively
      await Promise.all(projects.map(p => loadProjectFavicon(p)));

      // Populate UI
      renderProjectList();
      resetCapsulesFromProjects();
    }

    function sanitizeProject(p, index){
      const out = {
        title: (p && typeof p.title === 'string' && p.title.trim()) ? p.title.trim() : `Project ${index+1}`,
        name: (p && typeof p.name === 'string' && p.name.trim()) ? p.name.trim() : `project-${index+1}`,
        description: (p && typeof p.description === 'string') ? p.description.trim() : '',
        favicon: (p && typeof p.favicon === 'string') ? p.favicon.trim() : ''
      };
      // defensive size-limit for strings
      out.title = out.title.slice(0, 120);
      out.description = out.description.slice(0, 400);
      return out;
    }

    function renderProjectList(){
      projectsList.innerHTML = '';
      projects.forEach((p, i) => {
        const row = document.createElement('div');
        row.className = 'proj';
        row.setAttribute('role','listitem');
        row.tabIndex = 0;

        const img = document.createElement('img');
        const imgSrc = p._imageSrc || p.favicon || '';
        img.src = imgSrc || defaultFaviconDataUrl || '';
        img.alt = p.title + ' icon';
        img.onerror = ()=>{ img.src = defaultFaviconDataUrl; };

        const txt = document.createElement('div');
        txt.className = 'txt';
        const title = document.createElement('div');
        title.className = 'title'; title.textContent = p.title;
        const desc = document.createElement('div');
        desc.className = 'desc'; desc.textContent = p.description || 'No description provided';

        txt.appendChild(title); txt.appendChild(desc);
        row.appendChild(img); row.appendChild(txt);

        row.addEventListener('click', ()=>selectProject(i));
        row.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') selectProject(i); });

        projectsList.appendChild(row);
      });
      selectProject(0);
    }

    function selectProject(i){
      const p = projects[i % projects.length];
      selectedTitle.textContent = p.title;
      selectedDesc.textContent = p.description || 'No description';
    }

    async function loadProjectFavicon(p){
      // Attempt to load favicon; if empty or invalid, let it fall back later.
      if(!p.favicon) return;
      try{
        const img = await loadImage(p.favicon, 36, 36);
        p._imageSrc = img.src;
        imagesByUrl.set(p.favicon, img);
      } catch(e){
        console.warn('favicon load failed for', p.favicon, e);
      }
    }

    function loadImage(url, w, h, timeout=4000){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        let finished = false;
        const to = setTimeout(()=>{ if(!finished){ finished = true; img.onload = img.onerror = null; reject(new Error('Image load timeout')); }}, timeout);
        img.crossOrigin = "anonymous";
        img.onload = () => { if(finished) return; finished = true; clearTimeout(to); resolve(img); };
        img.onerror = (e) => { if(finished) return; finished = true; clearTimeout(to); reject(new Error('Image error')); };
        img.src = url;
      });
    }

    /* ---------------------------
       Create placeholder favicon
       --------------------------- */
    function makePlaceholderFavicon(){
      const c = document.createElement('canvas');
      c.width = c.height = 64;
      const g = c.getContext('2d');
      g.fillStyle = '#223';
      g.fillRect(0,0,64,64);
      g.fillStyle = '#ffd166';
      g.font = 'bold 36px sans-serif';
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.fillText('P',32,34);
      defaultFaviconDataUrl = c.toDataURL();
    }

    /* ---------------------------
       Capsules / physics (simple)
       --------------------------- */
    function resetCapsulesFromProjects(){
      capsules = [];
      const count = Math.min(MAX_CAPSULES, Math.max(3, projects.length));
      for(let i=0;i<count;i++){
        const pj = projects[i % projects.length];
        const cx = playX + 24 + ((i%3) * ((playW-48)/3));
        const cy = playY + playH - 48 - Math.floor(i/3)*28;
        capsules.push({
          x: cx + rand(-6,6), y: cy + rand(-6,6),
          r: 22, vy:0,
          projectIndex: i % projects.length,
          grabbed: false
        });
      }
    }

    /* ---------------------------
       Rendering
       --------------------------- */
    function drawBackground(){
      // cabinet frame
      ctx.clearRect(0,0,W,H);
      // outer glass
      ctx.fillStyle = '#071025';
      roundRect(ctx, playX-8, playY-18, playW+16, playH+36, 12);
      ctx.fill();

      // inner ground
      ctx.fillStyle = '#0b1220';
      roundRect(ctx, playX, playY, playW, playH, 8);
      ctx.fill();

      // floor strip
      ctx.fillStyle = '#071024';
      ctx.fillRect(playX, playY+playH-28, playW, 28);

      // top rail
      ctx.fillStyle = '#0b1928';
      ctx.fillRect(playX, playY-18, playW, 18);
    }

    function drawCapsule(c){
      // capsule shadow
      ctx.beginPath();
      ctx.ellipse(c.x, c.y + c.r*0.7, c.r*1.05, c.r*0.4, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fill();

      // capsule body
      ctx.beginPath();
      ctx.fillStyle = '#ffd166';
      roundRect(ctx, c.x - c.r, c.y - c.r, c.r*2, c.r*2, c.r*0.6);
      ctx.fill();

      // inner circle for favicon
      ctx.save();
      ctx.beginPath();
      ctx.arc(c.x, c.y - 2, c.r*0.7, 0, Math.PI*2);
      ctx.clip();

      const project = projects[c.projectIndex];
      const imgSrc = project && project._imageSrc ? project._imageSrc : defaultFaviconDataUrl;
      if(imgSrc){
        const img = imagesByUrl.get(project.favicon);
        // draw image with fallback to cached src
        const imageObj = img || new Image();
        if(!img){
          imageObj.src = imgSrc;
          imageObj.onerror = ()=>{};
        }
        try { ctx.drawImage(imageObj, c.x - c.r*0.7, c.y - 2 - c.r*0.7, c.r*1.4, c.r*1.4); } catch(e){}
      }
      ctx.restore();

      // highlight
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.ellipse(c.x - c.r*0.35, c.y - c.r*0.45, c.r*0.35, c.r*0.2, 0, 0, Math.PI*2);
      ctx.fill();
    }

    function drawClaw(){
      // arm line
      ctx.strokeStyle = '#e6eef6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(playX + playW/2, playY - 6);
      ctx.lineTo(claw.x, claw.y);
      ctx.stroke();

      // claw body
      roundRect(ctx, claw.x - claw.width/2, claw.y, claw.width, claw.height, 6);
      ctx.fillStyle = '#bcc8d8';
      ctx.fill();

      // tines
      ctx.fillStyle = '#0b1224';
      ctx.fillRect(claw.x - 12, claw.y + claw.height - 2, 6, 12);
      ctx.fillRect(claw.x + 6, claw.y + claw.height - 2, 6, 12);
    }

    function render(){
      drawBackground();

      // draw capsules (z-order depends on y)
      const sorted = capsules.slice().sort((a,b)=>a.y - b.y);
      for(const c of sorted) drawCapsule(c);

      // draw grab area highlight
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,209,102,0.12)';
      ctx.lineWidth = 2;
      ctx.ellipse(claw.x, claw.y + claw.armLength, 46, 28, 0, 0, Math.PI*2);
      ctx.stroke();

      drawClaw();

      // HUD: remaining capsules
      ctx.fillStyle = '#9aa4b2';
      ctx.font = '12px sans-serif';
      ctx.fillText(`Prizes: ${capsules.filter(c=>!c.grabbed).length}`, playX + 8, playY + playH + 22);
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    /* ---------------------------
       Game loop / physics
       --------------------------- */
    function step(ts){
      if(!lastTime) lastTime = ts;
      const dt = Math.min(50, ts - lastTime) / 1000;
      lastTime = ts;

      // Input to claw horizontal velocity
      if(!claw.lockInput){
        let move = 0;
        if(input.left) move -= 1;
        if(input.right) move += 1;
        claw.vx = move * claw.speed;
      } else {
        claw.vx = 0;
      }

      // Update claw position
      claw.x += claw.vx * dt;
      claw.x = clamp(claw.x, playX + 20, playX + playW - 20);

      // State machine
      if(claw.state === 'idle'){
        // allow lowering when down or grab pressed
        if((input.down || input.grab) && !claw.lockInput){
          startLowering();
        }
      } else if(claw.state === 'lowering'){
        // claw moves down until armLength reached or hits a capsule
        claw.armLength += 180 * dt;
        const tipY = claw.y + claw.armLength;
        // clamp to ground
        if(tipY >= playY + playH - 34){
          claw.armLength = (playY + playH - 34) - claw.y;
          beginGrabbing();
        } else {
          // collision with any capsule within grab radius
          const hit = capsules.find(c=>!c.grabbed && dist(c.x, c.y, claw.x, tipY) < 34);
          if(hit){
            beginGrabbing(hit);
          }
        }
      } else if(claw.state === 'grabbing'){
        claw.grabTimer -= dt;
        if(claw.grabTimer <= 0){ // resolve grab
          resolveGrab();
        }
      } else if(claw.state === 'lifting'){
        // pull the claw back up smoothly
        claw.armLength -= 160 * dt;
        if(claw.armLength <= 80){
          claw.armLength = 80;
          claw.state = 'moving';
          // after raising, drop if nothing held or deliver prize
          scheduleTimeout(()=>{ if(claw.hold !== null){ deliverPrize(claw.hold); } else { claw.state = 'idle'; claw.lockInput = false; } }, 300);
        }
        // carry held capsule with claw
        if(claw.hold !== null){
          const c = capsules[claw.hold];
          c.x = claw.x;
          c.y = claw.y + claw.armLength + 10;
        }
      } else if(claw.state === 'moving'){
        // simple move-back to center
        const centerX = playX + playW/2;
        const dx = centerX - claw.x;
        claw.x += Math.sign(dx) * claw.speed * dt;
        if(Math.abs(dx) < 4){
          claw.x = centerX;
          claw.state = 'idle';
          claw.lockInput = false;
        }
      } else if(claw.state === 'dropping'){
        // currently used for drop animations; handled in deliverPrize
      }

      // capsules physics (gravity)
      for(let i = 0; i < capsules.length; i++){
        const c = capsules[i];
        if(c.grabbed) continue;
        // simple gravity toward floor
        if(c.y < playY + playH - 42){
          c.vy += 400 * dt;
          c.y += c.vy * dt;
        } else {
          // on ground - small settle
          c.vy = 0;
          c.y = playY + playH - 42;
        }
        // push away overlapping capsules
        for(let j=i+1;j<capsules.length;j++){
          const d2 = dist(c.x,c.y,capsules[j].x,capsules[j].y);
          const minD = c.r + capsules[j].r - 6;
          if(d2 < minD && d2 > 0.1){
            const push = (minD - d2) * 0.5;
            const ang = Math.atan2(capsules[j].y - c.y, capsules[j].x - c.x);
            capsules[j].x += Math.cos(ang) * push;
            capsules[j].y += Math.sin(ang) * push;
            c.x -= Math.cos(ang) * push;
            c.y -= Math.sin(ang) * push;
            // keep in bounds
            c.x = clamp(c.x, playX + 20, playX + playW - 20);
            capsules[j].x = clamp(capsules[j].x, playX + 20, playX + playW - 20);
          }
        }
      }

      render();
      animationId = requestAnimationFrame(step);
    }

    function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

    /* ---------------------------
       Claw actions
       --------------------------- */
    function startLowering(){
      if(claw.state !== 'idle') return;
      claw.lockInput = true;
      claw.state = 'lowering';
      claw.armLength = 80; // start length if necessary
    }

    function beginGrabbing(target){
      claw.state = 'grabbing';
      claw.grabTimer = 0.6 + Math.random() * 0.8; // suspense
      if(target){
        target.grabbed = true;
        claw.hold = capsules.indexOf(target);
      } else {
        claw.hold = null;
      }
    }

    function resolveGrab(){
      // determine probabilistic success if nothing physically grabbed
      if(claw.hold === null){
        const success = Math.random() < 0.33; // low chance of lucky grab
        if(success){
          // find capsule nearest to tip at time of resolution
          const tipY = claw.y + claw.armLength;
          const nearest = capsules.filter(c=>!c.grabbed).map(c=>({c, d: dist(c.x,c.y, claw.x, tipY)})).sort((a,b)=>a.d-b.d)[0];
          if(nearest && nearest.d < 50){
            nearest.c.grabbed = true;
            claw.hold = capsules.indexOf(nearest.c);
          }
        }
      }
      // go to lifting
      claw.state = 'lifting';
    }

    function deliverPrize(index){
      if(index == null || index < 0 || index >= capsules.length) {
        claw.state = 'moving';
        claw.lockInput = false;
        return;
      }
      // animate drop into chute (right side)
      claw.state = 'dropping';
      const c = capsules[index];
      const targetX = playX + playW - 32;
      const targetY = playY + playH + 52;
      const start = {x: c.x, y: c.y};
      const duration = 700;
      const t0 = performance.now();
      function animateDrop(now){
        const t = clamp((now - t0) / duration, 0, 1);
        // easing
        const ease = (--t) * t * t + 1;
        c.x = start.x + (targetX - start.x) * ease;
        c.y = start.y + (targetY - start.y) * ease;
        render();
        if(ease < 1){
          requestAnimationFrame(animateDrop);
        } else {
          // prize delivered — reveal metadata
          announcePrize(c.projectIndex);
          // remove capsule from array after small delay
          const idx = capsules.indexOf(c);
          if(idx >= 0) capsules.splice(idx,1);
          claw.hold = null;
          claw.state = 'moving';
          claw.lockInput = false;
          // if no capsules, refill from projects
          if(capsules.length === 0) scheduleTimeout(resetCapsulesFromProjects, 600);
        }
      }
      requestAnimationFrame(animateDrop);
    }

    function announcePrize(projectIndex){
      const p = projects[projectIndex];
      if(!p) return;
      selectedTitle.textContent = p.title;
      selectedDesc.textContent = p.description || '';
      // small visual flash
      flashSelected();
    }

    function flashSelected(){
      const orig = selectedTitle.style.backgroundColor;
      selectedTitle.style.transition = 'background-color 260ms';
      selectedTitle.style.backgroundColor = '#ffd166';
      scheduleTimeout(()=>{ selectedTitle.style.backgroundColor = orig; }, 300);
    }

    /* ---------------------------
       Input handling (pointer & keys)
       --------------------------- */
    function attachInput(){
      // keyboard
      window.addEventListener('keydown', onKey);
      window.addEventListener('keyup', onKeyUp);

      // buttons
      leftBtn.addEventListener('pointerdown', ()=>{ input.left = true; });
      leftBtn.addEventListener('pointerup', ()=>{ input.left = false; });
      leftBtn.addEventListener('pointerleave', ()=>{ input.left = false; });

      rightBtn.addEventListener('pointerdown', ()=>{ input.right = true; });
      rightBtn.addEventListener('pointerup', ()=>{ input.right = false; });
      rightBtn.addEventListener('pointerleave', ()=>{ input.right = false; });

      downBtn.addEventListener('click', ()=>{ input.down = true; scheduleTimeout(()=>input.down=false, 160); });

      grabBtn.addEventListener('click', ()=>{ input.grab = true; scheduleTimeout(()=>input.grab=false, 160); });

      // pointer drag on canvas to move claw
      let activePointer = null;
      canvas.addEventListener('pointerdown', (e)=>{
        activePointer = e.pointerId;
        canvas.setPointerCapture(activePointer);
        const rect = canvas.getBoundingClientRect();
        const px = (e.clientX - rect.left); // CSS coords
        claw.x = clamp(px, playX + 20, playX + playW - 20);
      });
      canvas.addEventListener('pointermove', (e)=>{
        if(e.pointerId !== activePointer) return;
        const rect = canvas.getBoundingClientRect();
        const px = (e.clientX - rect.left);
        claw.x = clamp(px, playX + 20, playX + playW - 20);
      });
      canvas.addEventListener('pointerup', (e)=>{
        if(e.pointerId !== activePointer) return;
        try{ canvas.releasePointerCapture(activePointer);}catch(e){}
        activePointer = null;
      });

      reloadBtn.addEventListener('click', ()=> loadProjects());
    }

    function onKey(e){
      if(e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
      if(e.key === 'ArrowRight' || e.key === 'd') input.right = true;
      if(e.key === 'ArrowDown' || e.key === 's') input.down = true;
      if(e.key === ' ' || e.code === 'Space') { input.grab = true; e.preventDefault(); }
    }
    function onKeyUp(e){
      if(e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
      if(e.key === 'ArrowRight' || e.key === 'd') input.right = false;
      if(e.key === 'ArrowDown' || e.key === 's') input.down = false;
      if(e.key === ' ' || e.code === 'Space') { input.grab = false; }
    }

    /* ---------------------------
       Lifecycle and cleanup
       --------------------------- */
    function start(){
      makePlaceholderFavicon();
      attachInput();
      loadProjects();
      cancelAnimationFrame(animationId);
      animationId = requestAnimationFrame(step);
      // defensive: stop everything if page hidden
      document.addEventListener('visibilitychange', ()=> {
        if(document.hidden){ cancelAnimationFrame(animationId); clearAllTimers(); }
        else { lastTime = 0; animationId = requestAnimationFrame(step); }
      });
      window.addEventListener('beforeunload', cleanup);
      window.addEventListener('unload', cleanup);
    }

    function cleanup(){
      cancelAnimationFrame(animationId);
      clearAllTimers();
      window.removeEventListener('keydown', onKey);
      window.removeEventListener('keyup', onKeyUp);
      document.removeEventListener('visibilitychange', ()=>{});
      window.removeEventListener('beforeunload', cleanup);
      window.removeEventListener('unload', cleanup);
    }

    // start app
    start();

    // export for debugging (optional)
    window.__claw = { resetCapsulesFromProjects, loadProjects, projects, capsules };
  })();
  </script>
</body>
</html>
