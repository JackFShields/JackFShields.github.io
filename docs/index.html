<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>JackFShields — Infinite Hallway</title>
<style>
  :root {
    --bg: #0a0f1c;
    --card-bg: rgba(255,255,255,0.02);
    --border: rgba(255,255,255,0.08);
    --text: #e6eef6;
    --muted: rgba(190,215,240,0.7);
    --accent: #4cc1ff;
  }

  * { margin:0; padding:0; box-sizing:border-box; }
  html,body { height:100%; background: linear-gradient(to bottom, #0a0f1c 0%, #040812 50%, #000000 100%); color: var(--text); font-family: Inter, system-ui, sans-serif; overflow: hidden; }

  .hallway { position: absolute; inset: 0; perspective: 800px; perspective-origin: 50% 50%; display:block; }
  .floor {
    position: absolute; bottom: 0; left: -200%; right: -200%; height: 48%;
    background-image:
      linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
      linear-gradient(0deg, rgba(255,255,255,0.02) 1px, transparent 1px);
    background-size: 100px 100px;
    transform: rotateX(80deg) translateZ(-300px);
    opacity: 0.55;
    pointer-events: none;
  }

  /* card base */
  .card {
    position: absolute;
    left: 50%;
    top: 46%;
    width: 320px;
    height: 200px;
    transform-style: preserve-3d;
    transform: translate(-50%, -50%) translateZ(var(--z, -200px));
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    box-shadow: 0 26px 50px rgba(0,0,0,0.6);
    transition: transform 220ms ease, opacity 220ms ease, filter 220ms ease;
    cursor: pointer;
    user-select: none;
    backface-visibility: hidden;
  }
  .card .meta { background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.28)); padding:10px; border-radius:8px; width:100%; }
  .card h3 { margin:0 0 6px 0; font-size:1.15rem; color:var(--text); }
  .card p { margin:0; color:var(--muted); font-size:0.92rem; line-height:1.2; }

  .card .accent { position:absolute; right:16px; top:16px; width:12px; height:12px; border-radius:4px; background:var(--accent); }

  /* fog & depth cues */
  .card::after {
    content: "";
    position: absolute; inset: 0;
    border-radius: 12px;
    pointer-events: none;
    background: linear-gradient(transparent, rgba(0,0,0,0.6));
    opacity: 0.6;
  }

  /* hidden when too close/behind camera */
  .card.behind { opacity: 0; pointer-events: none; transform: translate(-50%, -50%) translateZ(200px) scale(.8); filter: blur(2px); }

  .hint { position: fixed; bottom: 28px; left: 50%; transform: translateX(-50%); color:var(--muted); font-size:0.95rem; text-align:center; z-index:2000; }

  .scroll-track { position: fixed; right: 22px; top: 50%; transform: translateY(-50%); width: 6px; height: 260px; background: rgba(255,255,255,0.04); border-radius: 6px; z-index:2000; }
  .scroll-thumb { position: absolute; width:100%; height: 36px; background: linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.06)); border-radius:4px; top:0; transition: top 120ms linear; }

  @media (max-width:800px) {
    .card { width:260px; height:170px; }
    .scroll-track { display:none; }
  }
</style>
</head>
<body>
  <div class="hallway" id="hallwayRoot">
    <div class="floor" aria-hidden="true"></div>
    <!-- cards injected by JS -->
    <div class="hint">Scroll / wheel or drag to move through the hallway • Click a card to open</div>
    <div class="scroll-track" aria-hidden="true"><div class="scroll-thumb" id="scrollThumb"></div></div>
  </div>

<script>
/* Infinite Hallway
   - Simple visual: cards live at Z positions spaced by CARD_SPACING.
   - Scrolling/dragging increases scrollZ; when a card crosses the camera (z > CAMERA_THRESHOLD),
     it teleports to the far back (z -= TOTAL_DEPTH) and its content index advances circularly.
   - Cards always display a wrapped project index so no negatives.
*/

const projects = [
  { title: "Minesweeper", subtitle: "Interactive tile-based puzzle", color: "#e74c3c", url: "https://github.com/JackFShields/minesweeper" },
  { title: "Poly Weave", subtitle: "Generative geometry experiments", color: "#9b59b6", url: "" },
  { title: "Grid Tools", subtitle: "UI toolkit for responsive grids", color: "#1abc9c", url: "" },
  { title: "UX Microinteractions", subtitle: "Interaction experiments", color: "#f39c12", url: "" },
  { title: "Data Viz Playground", subtitle: "Algorithmic visualizations", color: "#27ae60", url: "" },
  { title: "Portfolio Experiments", subtitle: "Design systems and transitions", color: "#34495e", url: "" }
];

const CARD_COUNT = 12;            // how many DOM cards live in the hallway
const CARD_SPACING = 320;         // distance in px between successive cards in Z
const SCROLL_SPEED = 0.9;         // multiplier for wheel/pointer movement -> deltaZ
const CAMERA_THRESHOLD = 120;     // when a card's z becomes > this it's considered 'passed camera'
const START_Z = -CARD_SPACING * 2; // initial offset for first card (so some appear close)
const TOTAL_DEPTH = CARD_COUNT * CARD_SPACING;

const root = document.getElementById('hallwayRoot');
const thumb = document.getElementById('scrollThumb');

let scrollZ = 0;                  // global scroll offset (in Z units)
let cardNodes = [];               // {el, z, logicalIndex}
let pointerActive = false;
let pointerStartX = 0;
let pointerStartY = 0;
let pointerAccum = 0;

// helpers
const mod = (n,m) => ((n % m) + m) % m;
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

// build cards
function createCard(i) {
  const el = document.createElement('div');
  el.className = 'card';
  el.setAttribute('role','button');
  el.setAttribute('tabindex','0');
  el.innerHTML = `
    <div class="accent" aria-hidden="true" style="background:${projects[0].color}"></div>
    <div class="meta"><h3 class="title">Loading…</h3><p class="subtitle">…</p></div>
  `;
  root.appendChild(el);
  return el;
}

function seedCards() {
  cardNodes = [];
  for (let i = 0; i < CARD_COUNT; i++) {
    const el = createCard(i);
    // position them along negative Z so they recede from camera: start from START_Z and step by CARD_SPACING
    const z = START_Z - i * CARD_SPACING;
    const logicalIndex = i; // will map to projects via wrap
    cardNodes.push({ el, z, logicalIndex });
  }
  renderAll();
}

// set DOM transform & content for a single card node
function renderCardNode(node) {
  node.el.style.setProperty('--z', `${node.z}px`);
  node.el.style.transform = `translate(-50%, -50%) translateZ(${node.z}px)`;
  // visual scale/tilt based on z (closer = slightly larger and brighter)
  const depthFactor = clamp(1 + (node.z / 1200), 0.6, 1.12);
  node.el.style.opacity = (node.z > CAMERA_THRESHOLD) ? '0' : clamp(1 + node.z / 600, 0.4, 1).toString();
  node.el.style.filter = `brightness(${depthFactor})`;
  // update content mapped to a wrapped project index
  const projectIdx = mod(node.logicalIndex, projects.length);
  const p = projects[projectIdx] || {};
  const title = node.el.querySelector('.title');
  const sub = node.el.querySelector('.subtitle');
  const acc = node.el.querySelector('.accent');
  title.textContent = p.title || `Project ${projectIdx+1}`;
  sub.textContent = p.subtitle || p.desc || '';
  acc.style.background = p.color || '#888';
  // mark behind when past camera threshold
  if (node.z > CAMERA_THRESHOLD) node.el.classList.add('behind'); else node.el.classList.remove('behind');
  // attach dataset index for click handling
  node.el.dataset.project = projectIdx;
}

// render all cards
function renderAll() {
  cardNodes.forEach(renderCardNode);
  // update scroll thumb position (visual only; map scrollZ in [0 .. TOTAL_DEPTH) to track)
  const t = mod(Math.round(scrollZ), TOTAL_DEPTH) / TOTAL_DEPTH;
  const trackH = 260 - 36;
  if (thumb) thumb.style.top = `${t * trackH}px`;
}

// advance global scroll by deltaZ, then recycle cards that passed camera
function advanceScroll(deltaZ) {
  scrollZ += deltaZ;
  // move each node forward by deltaZ (in z-space, which is negative -> positive moves toward camera)
  for (const node of cardNodes) node.z += deltaZ;

  // recycle nodes that passed the camera (z > CAMERA_THRESHOLD)
  for (const node of cardNodes) {
    if (node.z > CAMERA_THRESHOLD) {
      // teleport to back by subtracting TOTAL_DEPTH
      node.z -= TOTAL_DEPTH;
      // advance logicalIndex so content appears new (keeps perceived infinite ordering)
      // Use logicalIndex += CARD_COUNT to keep monotonic increase (modded when rendering)
      node.logicalIndex += CARD_COUNT;
    }
  }
  renderAll();
}

// wheel handler for scroll
function onWheel(e) {
  e.preventDefault();
  const delta = (e.deltaY || e.wheelDeltaY || e.wheelDelta || -e.deltaX) * 0.02;
  advanceScroll(-delta * SCROLL_SPEED * 20);
}

// pointer drag for horizontal/vertical dragging mapped to Z
function onPointerDown(e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  pointerActive = true;
  pointerStartX = e.clientX;
  pointerStartY = e.clientY;
  pointerAccum = 0;
  root.setPointerCapture?.(e.pointerId);
}
function onPointerMove(e) {
  if (!pointerActive) return;
  const dx = e.clientX - pointerStartX;
  const dy = e.clientY - pointerStartY;
  // map vertical drag primarily to Z, horizontal small influence for parallax feel
  const delta = ( -dy * 0.8 + -dx * 0.15 ) * 0.7;
  // throttle: only apply significant moves
  pointerAccum += delta;
  if (Math.abs(pointerAccum) > 6) {
    advanceScroll(pointerAccum * 0.6);
    pointerAccum = 0;
    pointerStartX = e.clientX;
    pointerStartY = e.clientY;
  }
}
function onPointerUp(e) {
  pointerActive = false;
  try { root.releasePointerCapture?.(e.pointerId); } catch(_) {}
}

// click handler opens project or zooms
function onCardClick(e) {
  const el = e.currentTarget;
  const idx = Number(el.dataset.project);
  if (!Number.isFinite(idx)) return;
  const p = projects[idx];
  if (p && p.url) {
    // subtle zoom animation before open
    el.style.transition = 'transform 260ms ease';
    el.style.transform += ' scale(1.08)';
    setTimeout(() => { window.open(p.url, '_blank'); el.style.transform = el.style.transform.replace(' scale(1.08)', ''); }, 220);
  } else {
    // simple attention animation for items without URL
    el.animate([{ transform: el.style.transform + ' translateY(0px)' }, { transform: el.style.transform + ' translateY(-12px)' }, { transform: el.style.transform + ' translateY(0px)' }], { duration: 360, easing: 'ease-out' });
  }
}

// keyboard: up/down or w/s to move forward/back
function onKey(e) {
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') advanceScroll(-CARD_SPACING);
  if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') advanceScroll(CARD_SPACING);
  if (e.key === ' ') { e.preventDefault(); advanceScroll(-CARD_SPACING * 1.5); } // jump forward
}

// initialize DOM cards and events
function init() {
  seedCards();
  // attach click handlers
  for (const node of cardNodes) {
    node.el.addEventListener('click', onCardClick);
    node.el.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); node.el.click(); }});
  }

  // wheel
  window.addEventListener('wheel', onWheel, { passive: false });

  // pointer drag on root
  root.addEventListener('pointerdown', onPointerDown);
  root.addEventListener('pointermove', onPointerMove);
  root.addEventListener('pointerup', onPointerUp);
  root.addEventListener('pointercancel', onPointerUp);

  // keyboard
  window.addEventListener('keydown', onKey);

  // initial render
  renderAll();
}

// seedCards uses createCard which appends to root; expose it here so createCard is available
seedCards = seedCards || function(){};
init();
</script>
</body>
</html>
