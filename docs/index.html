<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>JackFShields — Cube Illusion (Bento layout + projects.json)</title>
<style>
  :root{
    --bg:#071425;
    --panel-grad: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.01));
    --border: rgba(255,255,255,0.08);
    --text:#e6eef6;
    --muted: rgba(190,215,240,0.7);
    --accent:#4cc1ff;
    --gap:20px;
    --stage-size:360px;
  }

  html,body{height:100%;margin:0;background:radial-gradient(circle at 18% 16%, #00121a 0%, var(--bg) 30%, #000814 100%);color:var(--text);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:48px;box-sizing:border-box;gap:24px;}

  /* Bento grid container (preserve your layout) */
  .bento {
    width: min(1100px, 96%);
    display:grid;
    grid-template-columns: 1fr min(var(--stage-size), 36vw) 1fr;
    grid-template-rows: auto min(var(--stage-size), 36vw) auto;
    gap: var(--gap);
    align-items:start;
  }

  /* Left info column */
  .panel {
    background: var(--panel-grad);
    border:1px solid var(--border);
    border-radius:12px;
    padding:18px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  }
  .panel .title { margin:0 0 8px 0; font-weight:700; font-size:1.1rem; color:var(--text); }
  .panel .body { margin:0; color:var(--muted); font-size:0.95rem; }

  /* Right info column uses same styles */
  .left-col { grid-column:1 / 2; grid-row:1 / 3; display:flex; flex-direction:column; gap:var(--gap); }
  .right-col { grid-column:3 / 4; grid-row:1 / 3; display:flex; flex-direction:column; gap:var(--gap); }

  /* Stage cell (center) */
  .stage-cell { grid-column:2 / 3; grid-row:2 / 3; display:flex; align-items:center; justify-content:center; position:relative; }

  /* Fake cube stage (no preserve-3d required) */
  .stage {
    width:var(--stage-size);
    height:var(--stage-size);
    position:relative;
    perspective:900px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  /* We implement panels as horizontal carousel slides with depth illusion via skew/scale */
  .illusion {
    width:100%;
    height:100%;
    position:relative;
    overflow:visible;
  }

  .face-panel {
    position:absolute;
    top:50%;
    left:50%;
    width:70%;
    height:70%;
    transform-origin:center center;
    display:flex;
    align-items:flex-end;
    justify-content:flex-start;
    padding:16px;
    box-sizing:border-box;
    border-radius:12px;
    background: var(--panel-grad);
    border:1px solid var(--border);
    box-shadow: 0 18px 40px rgba(0,0,0,0.55);
    transition: transform 380ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease, filter 200ms ease;
    cursor:pointer;
    user-select:none;
  }

  .face-panel .meta { background:linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.28)); padding:10px; border-radius:8px; width:100%; }
  .face-panel h3 { margin:0 0 6px 0; font-size:1.05rem; color:var(--text); }
  .face-panel p { margin:0; color:var(--muted); font-size:0.9rem; }

  .face-panel .accent { position:absolute; right:12px; top:12px; width:12px; height:12px; border-radius:4px; }

  /* positions for 4 visible faces (front,right,back,left) expressed as offsets and transforms for illusion */
  /* Index 0 = front (center). Others translate horizontally and skew to imply rotation */
  .face-0 { transform: translate(-50%,-50%) translateX(0) scale(1) skewY(0deg); z-index:30; opacity:1; filter: none; }
  .face-1 { transform: translate(-50%,-50%) translateX(48%) scale(0.84) skewY(-12deg) translateZ(-10px); z-index:20; opacity:0.98; filter:brightness(.96); }
  .face-2 { transform: translate(-50%,-50%) translateX(96%) scale(0.68) skewY(-18deg) translateZ(-20px); z-index:10; opacity:0.86; filter:brightness(.9) blur(0.0px); pointer-events:none; }
  .face-3 { transform: translate(-50%,-50%) translateX(-48%) scale(0.84) skewY(12deg) translateZ(-10px); z-index:20; opacity:0.98; filter:brightness(.96); }
  .face-4 { transform: translate(-50%,-50%) translateX(-96%) scale(0.68) skewY(18deg) translateZ(-20px); z-index:10; opacity:0.86; filter:brightness(.9) blur(0.0px); pointer-events:none; }

  /* Top plate (visual only) - rotates/slides to match illusion */
  .top-plate {
    position:absolute;
    width:58%;
    height:20%;
    left:50%;
    top:18%;
    transform-origin:center center;
    transform: translateX(-50%) translateY(-50%) rotateX(60deg);
    border-radius:8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 12px 30px rgba(0,0,0,0.6) inset;
    transition: transform 380ms cubic-bezier(.2,.9,.2,1), opacity 380ms ease;
    pointer-events:none;
    opacity:0.8;
  }

  /* bottom buttons area (preserve your project shortcuts) */
  .controls { grid-column:1 / 4; grid-row:3 / 4; display:flex; align-items:center; justify-content:center; gap:12px; margin-top:8px; }
  .projects-list { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; max-width:1100px; }
  .project-btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); padding:8px 12px; border-radius:8px; cursor:pointer; font-size:0.92rem; }
  .project-btn.active { border-color:rgba(255,255,255,0.18); color:var(--text); background:rgba(255,255,255,0.02); }

  .hint { grid-column:1 / 4; text-align:center; color:var(--muted); font-size:0.88rem; margin-top:6px; }

  @media (max-width:980px) {
    .bento { grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
    .left-col, .right-col { grid-column:1; grid-row:auto; order:2; }
    .stage-cell { grid-column:1; order:1; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="bento" id="bentoRoot">
      <div class="left-col">
        <div class="panel" id="leftPanelTop">
          <div class="title" id="leftTitle">Loading…</div>
          <p class="body" id="leftBody">Loading subtitle…</p>
        </div>
        <div class="panel" id="leftPanelBottom">
          <div class="title" id="leftSmallTitle">Meta</div>
          <p class="body" id="leftSmallBody">Extra info</p>
        </div>
      </div>

      <div class="stage-cell">
        <div class="stage" aria-hidden="false">
          <div class="illusion" id="illusion">
            <!-- face panels (we render 5 slots: center + 2 left + 2 right for smooth motion) -->
            <div class="face-panel face-0" data-slot="0" role="button" tabindex="0">
              <div class="accent" aria-hidden="true"></div>
              <div class="meta">
                <h3 class="title">Loading…</h3>
                <p class="subtitle">Please wait</p>
              </div>
            </div>

            <div class="face-panel face-1" data-slot="1" role="button" tabindex="-1">
              <div class="accent" aria-hidden="true"></div>
              <div class="meta">
                <h3 class="title">Loading…</h3>
                <p class="subtitle">Please wait</p>
              </div>
            </div>

            <div class="face-panel face-2" data-slot="2" role="presentation" aria-hidden="true">
              <div class="accent" aria-hidden="true"></div>
              <div class="meta">
                <h3 class="title">Loading…</h3>
                <p class="subtitle">Please wait</p>
              </div>
            </div>

            <div class="face-panel face-3" data-slot="3" role="button" tabindex="-1">
              <div class="accent" aria-hidden="true"></div>
              <div class="meta">
                <h3 class="title">Loading…</h3>
                <p class="subtitle">Please wait</p>
              </div>
            </div>

            <div class="face-panel face-4" data-slot="4" role="presentation" aria-hidden="true">
              <div class="accent" aria-hidden="true"></div>
              <div class="meta">
                <h3 class="title">Loading…</h3>
                <p class="subtitle">Please wait</p>
              </div>
            </div>
          </div>

          <div class="top-plate" id="topPlate" aria-hidden="true"></div>
        </div>
      </div>

      <div class="right-col">
        <div class="panel" id="rightPanelTop">
          <div class="title" id="rightTitle">Loading…</div>
          <p class="body" id="rightBody">Loading subtitle…</p>
        </div>
        <div class="panel" id="rightPanelBottom">
          <div class="title" id="rightSmallTitle">Links</div>
          <p class="body" id="rightSmallBody">Project links</p>
        </div>
      </div>

      <div class="controls">
        <div class="projects-list" id="projectsList" aria-label="Project shortcuts"></div>
      </div>

      <div class="hint">Click a face to open; use the buttons to jump. This is a 3D illusion (no real 3D transforms).</div>
    </div>
  </div>

<script>
/*
  Fake-cube implementation (option 1) that:
  - preserves your bento layout
  - loads projects from docs/projects.json (fallback to inline if fetch fails)
  - provides clickable face panels and buttons
  - includes a visible top plate that moves to simulate rotation
  - avoids real preserve-3d collapsing issues by operating purely with 2D transforms, skew and scale
*/

/* --- Config --- */
const VISIBLE_SLOTS = 5; // we render five slots: indices relative to the current front
const SLOT_ORDER = [ -1, 0, 1, 2, 3 ]; // logical mapping for left-of-left .. right-most
const SLOT_CLASSES = ['face-3','face-0','face-1','face-2','face-4']; // matches markup order
const TRANSITION_MS = 380;
const PRELOAD_AHEAD = 12; // how many project thumbnails to preload (if images present)

/* --- State --- */
let projects = [];
let frontIndex = 0; // logical index of the project currently centered (front)
let isAnimating = false;
let queue = []; // queued jump targets (if desired later)
const illusion = document.getElementById('illusion');
const slotEls = Array.from(illusion.querySelectorAll('.face-panel'));
const topPlate = document.getElementById('topPlate');
const projectsList = document.getElementById('projectsList');

/* --- Load projects.json then init --- */
async function loadProjectsJSON() {
  try {
    const res = await fetch('/docs/projects.json');
    if (!res.ok) throw new Error('no projects.json');
    const data = await res.json();
    if (Array.isArray(data) && data.length) {
      projects = data;
    } else {
      throw new Error('invalid json');
    }
  } catch (e) {
    // fallback inline if fetch fails (safe and predictable)
    projects = [
      { title: "Minesweeper", subtitle: "Interactive tile-based puzzle", desc: "Classic minesweeper rebuilt", image: null, color: "#e74c3c" },
      { title: "Poly Weave", subtitle: "Generative geometry experiments", desc: "Woven polygons and creative coding", image: null, color: "#9b59b6" },
      { title: "Grid Tools", subtitle: "UI toolkit for responsive grids", desc: "Utilities for layouts", image: null, color: "#1abc9c" },
      { title: "UX Microinteractions", subtitle: "Interaction experiments", desc: "Playful loaders and toggles", image: null, color: "#f39c12" },
      { title: "Data Viz Playground", subtitle: "Algorithmic visualizations", desc: "Visual encodings and layouts", image: null, color: "#27ae60" },
      { title: "Portfolio Experiments", subtitle: "Design systems and transitions", desc: "Sandbox experiments", image: null, color: "#34495e" }
    ];
  }
  // preload images conservatively
  projects.slice(0, PRELOAD_AHEAD).forEach(p => { if (p.image) { const i = new Image(); i.src = p.image; }});
  renderProjectButtons();
  renderVisibleSlots();
  wireSlotInteractions();
  populateSidePanels();
}

/* --- Utility helpers --- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const mod = (n, m) => ((n % m) + m) % m;

/* --- Rendering slots (fake cube faces) --- */
function renderVisibleSlots() {
  // For each slot element, compute which project index it should show
  // Slot mapping chosen to create left-to-right visual order
  // center (face-0) shows frontIndex
  const mapping = [
    frontIndex - 1, // face-3 (left)
    frontIndex,     // face-0 (center)
    frontIndex + 1, // face-1 (right of center)
    frontIndex + 2, // face-2 (far right)
    frontIndex + 3  // face-4 (far left beyond)
  ];

  slotEls.forEach((slotEl, i) => {
    const projIdx = mapping[i];
    applySlotContent(slotEl, projIdx);
    // update accessibility: only center and near-center slots are tabbable
    const isInteractive = (i === 1 || i === 2 || i === 0); // center and immediate neighbors and left neighbor clickable
    slotEl.tabIndex = isInteractive ? 0 : -1;
    slotEl.setAttribute('role', isInteractive ? 'button' : 'presentation');
  });

  // animate topplate to reflect "rotation" direction/position
  updateTopPlateVisual();
}

function applySlotContent(slotEl, projIdx) {
  const titleEl = slotEl.querySelector('h3.title');
  const subEl = slotEl.querySelector('p.subtitle');
  const accent = slotEl.querySelector('.accent');

  if (projIdx < 0 || projIdx >= projects.length) {
    titleEl.textContent = `Project ${projIdx + 1}`;
    subEl.textContent = "Hold your horses! I haven't finished this yet!";
    accent.style.background = '#666';
    slotEl.style.backgroundImage = '';
    slotEl.dataset.index = projIdx;
    return;
  }

  const p = projects[projIdx];
  titleEl.textContent = p.title || `Project ${projIdx + 1}`;
  subEl.textContent = p.subtitle || p.desc || '';
  accent.style.background = p.color || '#888';
  if (p.image) slotEl.style.backgroundImage = `url(${p.image})`; else slotEl.style.backgroundImage = '';
  slotEl.dataset.index = projIdx;
}

/* --- Top plate visuals --- */
function updateTopPlateVisual() {
  // Position topPlate to give illusion of perspective based on frontIndex mod 4
  // We'll slide and skew slightly to suggest rotation direction
  const pos = frontIndex % projects.length;
  // compute a small lateral offset based on parity of frontIndex so it subtly moves
  const offset = (frontIndex % 2 === 0) ? -6 : 6;
  topPlate.style.transform = `translateX(${offset}px) translateY(-50%) rotateX(60deg)`;
}

/* --- Navigation (left/right steps) --- */
function stepTo(delta) {
  if (isAnimating) return;
  isAnimating = true;

  // Animate by shifting frontIndex then animate CSS transforms for slots
  const prevFront = frontIndex;
  frontIndex = frontIndex + delta;

  // We'll animate slot transforms by toggling classes with slight delay to smooth motion.
  // Implementation strategy: apply CSS class adjustments on illusion element
  //  - animate by translating the whole illusion container horizontally, then on end update content and reset transform.

  illusion.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.2,.9,.2,1)`;
  // push illusion left or right visually (negative delta moves left)
  const pixelShift = -delta * 34; // small visual nudge proportional to step
  illusion.style.transform = `translateX(${pixelShift}px)`;

  // temporarily reduce opacity of far slots
  slotEls.forEach((s, idx) => {
    s.style.transition = `transform ${TRANSITION_MS}ms cubic-bezier(.2,.9,.2,1), opacity ${TRANSITION_MS}ms ease`;
    // push visual ordering by updating class list (we rely on CSS classes for base transforms)
    // lightly dim far slots during motion
    if (Math.abs(idx - 1) > 1) { s.style.opacity = '0.7'; }
  });

  // on animation end, reset and re-render slots to new mapping
  setTimeout(() => {
    illusion.style.transition = '';
    illusion.style.transform = '';
    slotEls.forEach(s => { s.style.transition = ''; s.style.opacity = ''; });
    renderVisibleSlots();
    isAnimating = false;
  }, TRANSITION_MS + 20);
}

/* --- Click-to-jump --- */
function jumpTo(targetIdx) {
  if (isAnimating) return;
  // compute minimal delta (allow larger lists; here we prefer sign towards nearest)
  const N = Math.max(1, projects.length);
  const raw = targetIdx - frontIndex;
  let wrapped = ((raw % N) + N) % N;
  if (wrapped > N/2) wrapped -= N;
  // perform step animation in unit increments if small; otherwise animate once with delta
  // We'll animate a single step equivalent to wrapped (positive means move right)
  stepTo(wrapped);
}

/* --- Slot interaction wiring --- */
function wireSlotInteractions() {
  slotEls.forEach(s => {
    s.addEventListener('click', () => {
      const idx = parseInt(s.dataset.index, 10);
      if (Number.isFinite(idx)) {
        // clicking a non-front slot should center it (compute delta)
        const delta = idx - frontIndex;
        if (delta === 0) {
          // center clicked — open or perform action (placeholder)
          openProject(idx);
        } else {
          // move by delta (small)
          jumpTo(idx);
        }
      }
    });
    s.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        s.click();
      }
    });
  });
}

/* --- Open project action (placeholder) --- */
function openProject(idx) {
  if (idx < 0 || idx >= projects.length) {
    // nothing to open; show small feedback
    alert(`Project ${idx + 1} not finished yet.`);
    return;
  }
  const p = projects[idx];
  // default behavior: if there's a URL open it, otherwise alert
  if (p.url) {
    window.open(p.url, '_blank');
  } else {
    alert(`${p.title}\n\n${p.desc || p.subtitle || ''}`);
  }
}

/* --- Buttons rendering (bottom) --- */
function renderProjectButtons() {
  projectsList.innerHTML = '';
  projects.forEach((p, i) => {
    const btn = document.createElement('button');
    btn.className = 'project-btn';
    btn.textContent = p.title || `Project ${i + 1}`;
    btn.addEventListener('click', () => { jumpTo(i); });
    projectsList.appendChild(btn);
  });
  updateButtonsActiveState();
}

function updateButtonsActiveState() {
  Array.from(projectsList.children).forEach((btn, i) => {
    btn.classList.toggle('active', i === frontIndex);
  });
}

/* --- Side panels (left/right) content mapping preserves layout) --- */
function populateSidePanels() {
  // center content on current front and neighbors (keeps your bento boxes meaningful)
  const leftTitle = document.getElementById('leftTitle');
  const leftBody = document.getElementById('leftBody');
  const leftSmallTitle = document.getElementById('leftSmallTitle');
  const leftSmallBody = document.getElementById('leftSmallBody');

  const rightTitle = document.getElementById('rightTitle');
  const rightBody = document.getElementById('rightBody');
  const rightSmallTitle = document.getElementById('rightSmallTitle');
  const rightSmallBody = document.getElementById('rightSmallBody');

  const a = projects[mod(frontIndex, projects.length)] || {};
  const b = projects[mod(frontIndex + 1, projects.length)] || {};
  const c = projects[mod(frontIndex - 1, projects.length)] || {};

  leftTitle.textContent = c.title || `Project ${frontIndex}`;
  leftBody.textContent = c.subtitle || c.desc || '';
  leftSmallTitle.textContent = 'Preview';
  leftSmallBody.textContent = `Showing nearby: ${a.title || '…'}`;

  rightTitle.textContent = b.title || `Project ${frontIndex + 2}`;
  rightBody.textContent = b.subtitle || b.desc || '';
  rightSmallTitle.textContent = 'Links';
  rightSmallBody.textContent = b.url || '';
}

/* --- Kickoff and housekeeping --- */
function renderVisibleSlotsAndPanels() {
  renderVisibleSlots();
  populateSidePanels();
  updateButtonsActiveState();
}

// Re-render when frontIndex changes inside stepTo/jumpTo via renderVisibleSlots called there
function init() {
  loadProjectsJSON();
  // When frontIndex changes, keep side panels & buttons in sync
  const originalStepTo = stepTo;
  // no-op; stepTo already calls renderVisibleSlots at end
}

init();

/* Expose a tiny API for debugging in console */
window._cubeIllusion = {
  stepLeft: () => stepTo(-1),
  stepRight: () => stepTo(1),
  jumpTo,
  getState: () => ({ frontIndex, projectsCount: projects.length })
};
</script>
</body>
</html>
