<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JackFShields — Infinite Portfolio Cube (Fixed)</title>
  <style>
    :root{
      --bg:#071425;
      --panel-grad: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.01));
      --border: rgba(255,255,255,0.08);
      --text:#e6eef6;
      --muted: rgba(190,215,240,0.7);
      --cube-size: 320px;
    }

    html,body{height:100%;margin:0;background:radial-gradient(circle at 20% 20%, #00121a 0%, var(--bg) 40%, #000814 100%);color:var(--text);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
    .wrap{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;padding:48px;box-sizing:border-box;}

    /* Stage + 3D illusion */
    .stage{width:var(--cube-size);height:var(--cube-size);perspective:1400px;position:relative;}
    .cube{width:100%;height:100%;transform-style:preserve-3d;position:relative;cursor:grab;user-select:none;--rot:0deg;transform:rotateX(-12deg) rotateY(var(--rot));transition:transform 0.2s linear;}
    .cube:active{cursor:grabbing;}

    /* top face to suggest 3D (not interactive) */
    .top-surface{
      position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;border-radius:12px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      box-shadow: 0 20px 40px rgba(0,0,0,0.6) inset;
      transform: translateZ(96px) rotateX(90deg) scaleY(0.18); opacity:0.6;
      mix-blend-mode: overlay;
    }

    .face{
      position:absolute;width:100%;height:100%;left:0;top:0;display:flex;flex-direction:column;justify-content:flex-end;padding:18px;box-sizing:border-box;
      backface-visibility:hidden;border-radius:12px;background: var(--panel-grad), linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      border:1px solid var(--border); box-shadow: 0 8px 30px rgba(0,0,0,0.6), inset 0 0 30px rgba(255,255,255,0.01);
      transition: background-image 0.2s ease, transform 0.12s ease, opacity 0.12s ease;
      overflow:hidden;
    }

    .meta{ background: linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.35)); padding:10px; border-radius:8px; }
    .title{ font-weight:700; margin:0 0 6px 0; font-size:1.05rem; color:var(--text); }
    .subtitle{ margin:0; font-size:0.9rem; color:var(--muted); }

    .accent{ position:absolute; right:12px; top:12px; width:12px; height:12px; border-radius:4px; }

    .face.swapping{ opacity:0.98; filter:blur(0.3px); }
    .face.swapping .meta{ opacity:0.0; transition:opacity .12s ease; }

    /* positions for 4 readable faces (front/right/back/left) */
    .face.front { transform: rotateY(0deg) translateZ(calc(var(--cube-size) / 2)); }
    .face.right { transform: rotateY(90deg) translateZ(calc(var(--cube-size) / 2)); }
    .face.back  { transform: rotateY(180deg) translateZ(calc(var(--cube-size) / 2)); }
    .face.left  { transform: rotateY(-90deg) translateZ(calc(var(--cube-size) / 2)); }

    /* bottom project list */
    .projects-list{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;max-width:900px;margin-top:10px;}
    .project-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer;font-size:0.9rem;}
    .project-btn.active{border-color:rgba(255,255,255,0.18);color:var(--text);background:rgba(255,255,255,0.02);}
    .hint{font-size:0.85rem;color:var(--muted);margin-top:12px;text-align:center;}

    @media (max-width:800px){ .stage{transform:scale(0.85);} .projects-list{transform:scale(0.9);} }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <div class="stage" aria-hidden="false">
      <div class="cube" role="region" aria-label="Project cube" tabindex="0">
        <div class="top-surface" aria-hidden="true"></div>

        <div class="face front">
          <div class="accent"></div>
          <div class="meta">
            <h3 class="title">Loading…</h3>
            <p class="subtitle">Please wait</p>
          </div>
        </div>

        <div class="face right">
          <div class="accent"></div>
          <div class="meta">
            <h3 class="title">Loading…</h3>
            <p class="subtitle">Please wait</p>
          </div>
        </div>

        <div class="face back">
          <div class="accent"></div>
          <div class="meta">
            <h3 class="title">Loading…</h3>
            <p class="subtitle">Please wait</p>
          </div>
        </div>

        <div class="face left">
          <div class="accent"></div>
          <div class="meta">
            <h3 class="title">Loading…</h3>
            <p class="subtitle">Please wait</p>
          </div>
        </div>
      </div>
    </div>

    <div class="projects-list" aria-label="Project shortcuts"></div>
    <div class="hint">Drag left / right to rotate. Click a project to jump to it.</div>
  </div>

  <script>
    // ---------- CONFIG ----------
    const FACE_ORDER = ['front','right','back','left']; // clockwise ordering
    const SWAP_THRESHOLDS = { front:180, right:270, back:0, left:90 }; // when face is behind
    const COOLDOWN_DEGREES = 360;    // face must wait this many degrees to swap again
    const ROTATE_EASE_MS = 420;      // rotation animation time
    const SENSITIVITY = 0.25;        // drag px -> degrees

    // Inline projects array (no fetch). Replace or extend as you want.
    const projects = [
      { title: "Minesweeper", subtitle: "Interactive tile-based puzzle", desc: "Classic minesweeper rebuilt", image: null, color: "#e74c3c" },
      { title: "Poly Weave", subtitle: "Generative geometry experiments", desc: "Woven polygons and creative coding", image: null, color: "#9b59b6" },
      { title: "Grid Tools", subtitle: "UI toolkit for responsive grids", desc: "Utilities for layouts", image: null, color: "#1abc9c" },
      { title: "UX Microinteractions", subtitle: "Interaction experiments", desc: "Playful loaders and toggles", image: null, color: "#f39c12" },
      { title: "Data Viz Playground", subtitle: "Algorithmic visualizations", desc: "Visual encodings and layouts", image: null, color: "#27ae60" },
      { title: "Portfolio Experiments", subtitle: "Design systems and transitions", desc: "Sandbox experiments that informed this site", image: null, color: "#34495e" }
    ];

    // ---------- STATE ----------
    let faceAssignments = { front:0, right:1, back:2, left:3 }; // which project index each face currently shows (can exceed length -> placeholder)
    let totalAngle = 0;                // cumulative rotation in degrees (not clamped)
    let lastPointerX = null;
    let activePointerId = null;
    let isAnimating = false;
    let lastAnimationFrame = null;
    let cooldownTracker = { front: -Infinity, right: -Infinity, back: -Infinity, left: -Infinity };

    // DOM refs
    const cube = document.querySelector('.cube');
    const faceEls = {
      front: document.querySelector('.face.front'),
      right: document.querySelector('.face.right'),
      back: document.querySelector('.face.back'),
      left: document.querySelector('.face.left')
    };
    const projectButtonsContainer = document.querySelector('.projects-list');

    // ---------- HELPERS ----------
    const nowDeg = d => ((d % 360) + 360) % 360;
    const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
    const mod = (n,m) => ((n%m)+m)%m;

    // Preload images if present
    projects.forEach(p => { if(p.image){ const i=new Image(); i.src = p.image; }});

    // ---------- FACE CONTENT ----------
    function setFaceContent(faceName, projectIndex) {
      const el = faceEls[faceName];
      if(!el) return;
      el.classList.add('swapping');

      // short fade delay to avoid immediate pop
      setTimeout(() => {
        const titleEl = el.querySelector('.title');
        const subEl = el.querySelector('.subtitle');
        const accEl = el.querySelector('.accent');

        if(projectIndex >= projects.length) {
          // placeholder behavior per your request
          titleEl.textContent = `Project ${projectIndex + 1}`;
          subEl.textContent = "Hold your horses! I haven't finished this yet!";
          accEl.style.background = '#666';
          el.style.backgroundImage = '';
        } else {
          const p = projects[projectIndex];
          titleEl.textContent = p.title || `Project ${projectIndex + 1}`;
          subEl.textContent = p.subtitle || (p.desc || '');
          accEl.style.background = p.color || '#888';
          if(p.image) el.style.backgroundImage = `url(${p.image})`; else el.style.backgroundImage = '';
        }
        el.classList.remove('swapping');
      }, 100);
    }

    function updateAllFaces() {
      FACE_ORDER.forEach(face => setFaceContent(face, faceAssignments[face]));
      updateButtonsActiveState();
      // reflect current totalAngle visually
      cube.style.setProperty('--rot', `${totalAngle}deg`);
    }

    function updateButtonsActiveState() {
      const visibleIndex = faceAssignments.front;
      if(!projectButtonsContainer) return;
      Array.from(projectButtonsContainer.children).forEach((btn, i) => {
        btn.classList.toggle('active', i === visibleIndex);
      });
    }

    // ---------- THRESHOLD DETECTION ----------
    // Detect whether any face's "behind" threshold was crossed between prevTotal and currTotal
    function detectAndApplyThresholds(prevTotal, currTotal) {
      if (Math.abs(currTotal - prevTotal) < 1e-6) return;
      const direction = currTotal > prevTotal ? 1 : -1;

      FACE_ORDER.forEach(face => {
        const threshold = SWAP_THRESHOLDS[face];
        const prev = prevTotal;
        const curr = currTotal;
        // compute k range likely to contain thresholds between prev and curr
        const kMin = Math.floor((Math.min(prev, curr) - threshold) / 360) - 1;
        const kMax = Math.ceil((Math.max(prev, curr) - threshold) / 360) + 1;
        for(let k = kMin; k <= kMax; k++) {
          const absoluteThreshold = threshold + 360 * k;
          const crossed = (prev < absoluteThreshold && absoluteThreshold <= curr) ||
                          (curr <= absoluteThreshold && absoluteThreshold < prev);
          if(crossed) {
            if(absoluteThreshold - (cooldownTracker[face] || -Infinity) >= COOLDOWN_DEGREES) {
              // shift face's assigned index by 4 in rotation direction
              const deltaIndex = 4 * direction;
              faceAssignments[face] = faceAssignments[face] + deltaIndex;
              cooldownTracker[face] = absoluteThreshold;
              // update face content (placeholder logic inside)
              setFaceContent(face, faceAssignments[face]);
            }
          }
        }
      });
    }

    // ---------- ROTATION ANIMATION ----------
    function animateRotation(deltaAngle, cb) {
      if (lastAnimationFrame) {
        cancelAnimationFrame(lastAnimationFrame);
        lastAnimationFrame = null;
      }
      isAnimating = true;
      const from = totalAngle;
      const to = totalAngle + deltaAngle;
      const start = performance.now();
      const dur = ROTATE_EASE_MS;

      function tick(ts) {
        const p = clamp((ts - start) / dur, 0, 1);
        const eased = 1 - Math.pow(1 - p, 3); // ease-out cubic
        const cur = from + (to - from) * eased;
        cube.style.setProperty('--rot', `${cur}deg`);
        // detect thresholds across movement sweep
        detectAndApplyThresholds(totalAngle, cur);
        if(p < 1) {
          lastAnimationFrame = requestAnimationFrame(tick);
        } else {
          totalAngle = to;
          isAnimating = false;
          lastAnimationFrame = null;
          // final threshold application (cover any missed)
          detectAndApplyThresholds(from, totalAngle);
          if(cb) cb();
        }
      }
      lastAnimationFrame = requestAnimationFrame(tick);
    }

    // ---------- POINTER (DESKTOP) ----------
    function handlePointerDown(e) {
      // only left-button drag
      if(e.pointerType === 'mouse' && e.button !== 0) return;
      if(isAnimating) return;
      lastPointerX = e.clientX;
      activePointerId = e.pointerId;
      e.target.setPointerCapture?.(activePointerId);
    }

    function handlePointerMove(e) {
      if(activePointerId === null) return;
      if(e.pointerId !== activePointerId) return;
      if(lastPointerX === null) return;
      const dx = e.clientX - lastPointerX;
      lastPointerX = e.clientX;
      const ddeg = dx * SENSITIVITY;
      const prev = totalAngle;
      totalAngle = totalAngle + ddeg;
      // apply immediate visual rotation
      cube.style.setProperty('--rot', `${totalAngle}deg`);
      // detect thresholds between prev and totalAngle
      detectAndApplyThresholds(prev, totalAngle);
    }

    function handlePointerUp(e) {
      if(activePointerId === null) return;
      if(e.pointerId !== activePointerId) return;
      try { e.target.releasePointerCapture?.(activePointerId); } catch(_) {}
      activePointerId = null;
      lastPointerX = null;
      // snap to nearest 90 degrees and animate any remaining subtleties
      const snapped = Math.round(totalAngle / 90) * 90;
      const deltaAngle = snapped - totalAngle;
      animateRotation(deltaAngle);
    }

    function handlePointerCancel(e) {
      // same cleanup
      if(activePointerId === null) return;
      activePointerId = null;
      lastPointerX = null;
    }

    // ---------- CLICK-TO-JUMP NAVIGATION ----------
    // Rotate cube so that targetProjectIndex ends up visible on front.
    // Approach:
    //  - compute current logical front index (faceAssignments.front)
    //  - compute minimal signed step difference (can be negative)
    //  - set faceAssignments to consecutive range starting at target (so content is ready)
    //  - animate rotation by steps * 90 degrees (visual spin)
    function rotateCubeToProject(targetProjectIndex) {
      if(typeof targetProjectIndex !== 'number') return;
      // current front index
      const currentFront = faceAssignments.front;
      // compute signed shortest delta (in project steps)
      const rawDelta = targetProjectIndex - currentFront;
      // normalize to nearest wrap-around: prefer shorter direction
      const wrappedDelta = ((rawDelta + projects.length*1000) % projects.length);
      let steps = wrappedDelta;
      if(wrappedDelta > projects.length / 2) steps = wrappedDelta - projects.length; // take shorter negative route

      // prepare face assignments so they show target..target+3 when animation ends
      FACE_ORDER.forEach((face, i) => {
        faceAssignments[face] = targetProjectIndex + i;
      });
      // update faces immediately so they're ready (preload all thumbnails above)
      updateAllFaces();

      // animate by steps*90 degrees (positive steps => rotate right)
      const deltaAngle = steps * 90;
      animateRotation(deltaAngle);
    }

    // ---------- BUTTONS RENDERING ----------
    function renderProjectButtons() {
      if(!projectButtonsContainer) return;
      projectButtonsContainer.innerHTML = '';
      projects.forEach((p, idx) => {
        const btn = document.createElement('button');
        btn.className = 'project-btn';
        btn.textContent = p.title || `Project ${idx+1}`;
        btn.addEventListener('click', () => rotateCubeToProject(idx));
        projectButtonsContainer.appendChild(btn);
      });
      updateButtonsActiveState();
    }

    // ---------- INITIALIZATION ----------
    function attachListeners() {
      cube.addEventListener('pointerdown', handlePointerDown);
      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('pointercancel', handlePointerCancel);

      // keyboard left/right navigation (also respects threshold logic)
      window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowLeft') {
          // rotate left (show previous project)
          const prev = faceAssignments.front;
          const target = prev - 1;
          rotateCubeToProject(target);
        } else if(e.key === 'ArrowRight') {
          const prev = faceAssignments.front;
          const target = prev + 1;
          rotateCubeToProject(target);
        }
      });
    }

    // initial faces and buttons
    function init() {
      renderProjectButtons();
      updateAllFaces();
      attachListeners();
      // ensure cube CSS var initial
      cube.style.setProperty('--rot', `${totalAngle}deg`);
    }

    init();
  </script>
</body>
</html>
