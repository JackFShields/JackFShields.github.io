<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cube + Bento Portfolio</title>
<style>
  :root{
    --bg:#071425; --panel:rgba(255,255,255,0.03);
    --muted:rgba(190,215,240,0.7);
    --accent:#2f9bd8;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,system-ui,Roboto,Arial}
  .wrap{
    min-height:100vh;
    display:grid;
    grid-template-columns:1fr 520px 1fr;
    grid-template-rows:auto 520px auto;
    gap:28px;
    align-items:center;
    padding:36px;
    box-sizing:border-box;
  }

  /* Info panels (left column title/description, right image) */
  .title-panel{
    grid-column:1; grid-row:1; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    padding:18px; border-radius:12px;
    max-width:520px;
  }
  .title-panel h1{font-size:26px;margin:0 0 8px 0}
  .title-panel p{margin:0;color:var(--muted)}

  .image-panel{
    grid-column:3; grid-row:1; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    border-radius:12px;padding:12px;height:120px;display:flex;align-items:center;justify-content:center;
    color:var(--muted);
  }

  .description-panel{
    grid-column:1; grid-row:2; align-self:start;
    background:var(--panel); border:1px solid rgba(255,255,255,0.04);
    padding:14px;border-radius:12px;max-width:520px;
    min-height:120px;
  }

  /* Cube center area */
  .cube-container{grid-column:2;grid-row:2;position:relative;display:flex;align-items:center;justify-content:center}
  .scene{width:520px;height:520px;position:relative;perspective:1100px;touch-action:none;user-select:none}
  .cube{
    width:400px;height:400px;margin:auto;position:relative;transform-style:preserve-3d;
    transform:translateZ(-200px) rotateX(-12deg) rotateY(0deg);
    transition:transform 0.12s linear; will-change:transform;
  }
  .face{
    position:absolute;width:400px;height:400px;left:50%;top:50%;transform-style:preserve-3d;
    margin:-200px 0 0 -200px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;flex-direction:column;
    justify-content:flex-end;padding:18px;box-sizing:border-box;cursor:pointer;backface-visibility:hidden;
  }
  .face .thumb{position:absolute;left:18px;top:18px;right:18px;height:68%;border-radius:10px;background:#0c1220;color:var(--muted);display:flex;align-items:center;justify-content:center;font-weight:700}
  .face h3{margin:0 0 6px 0;font-size:20px}
  .face p{margin:0;color:var(--muted);font-size:13px}
  .meta{display:flex;justify-content:space-between;margin-top:8px;font-size:12px;color:var(--muted)}

  /* face transforms (adjacent ordering L->R: left, front, right, back) */
  .front { transform: rotateY(  0deg) translateZ(200px); }
  .right { transform: rotateY( 90deg) translateZ(200px); }
  .back  { transform: rotateY(180deg) translateZ(200px); }
  .left  { transform: rotateY(270deg) translateZ(200px); }
  .top   { transform: rotateX( 90deg) translateZ(200px); }
  .bottom{ transform: rotateX(-90deg) translateZ(200px); }

  /* Bento grid around cube, absolute and will be "pushed" by JS transforms */
  .bento {
    position:absolute; inset:0; pointer-events:none; display:grid; place-items:center;
  }
  .bento-grid{
    width:100%;max-width:760px;display:grid;grid-template-columns:repeat(3,1fr);grid-auto-rows:120px;gap:18px;align-items:center;justify-items:center;
    pointer-events:auto;
  }
  .card{
    width:100%;max-width:220px;height:110px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);padding:12px;box-sizing:border-box;display:flex;gap:10px;align-items:center;cursor:pointer;transition:transform .22s ease,box-shadow .22s ease;
  }
  .card:hover{transform:translateY(-6px);box-shadow:0 14px 30px rgba(2,6,23,0.6)}
  .card .thumb{width:84px;height:72px;border-radius:8px;background:linear-gradient(180deg,#0c1220,#081018);display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:700}
  .card .body h4{margin:0;font-size:14px}
  .card .body p{margin:6px 0 0 0;font-size:12px;color:var(--muted)}

  /* Expandable list under cube */
  .project-list{grid-column:2;grid-row:3;display:flex;flex-direction:column;gap:8px;max-width:760px;align-items:center}
  .project-list .header{width:100%;display:flex;justify-content:space-between;align-items:center}
  .project-list .expander{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;cursor:pointer}
  .project-list ul{list-style:none;width:100%;margin-top:8px;max-height:0;overflow:hidden;transition:max-height .36s ease}
  .project-list ul.open{max-height:300px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
  .project-list li{padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);display:flex;justify-content:space-between;gap:12px}

  /* small helpers */
  .hint{position:fixed;left:18px;bottom:18px;font-size:13px;color:var(--muted)}
  @media (max-width:980px){
    .wrap{grid-template-columns:1fr;grid-template-rows:auto auto auto;padding:20px;gap:18px}
    .cube-container{grid-column:1;grid-row:2}
    .title-panel{grid-column:1;grid-row:1}
    .image-panel{display:none}
    .description-panel{grid-column:1;grid-row:3}
    .project-list{grid-column:1;grid-row:4}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title-panel" id="titlePanel">
      <h1 id="projTitle">Minesweeper</h1>
      <p id="projSubtitle">Interactive tile-based puzzle</p>
    </div>

    <div class="image-panel" id="imagePanel">Image preview (shows the most visible face)</div>

    <div class="description-panel" id="descPanel">
      <p id="projDesc">Click or drag the cube. The title, description and image update to the face most visible.</p>
    </div>

    <div class="cube-container">
      <div class="scene" id="scene" aria-label="3D cube scene">
        <div class="cube" id="cube">
          <!-- faces use data-index for mapping to projects array -->
          <div class="face front"  data-slot="0" data-index="0">
            <div class="thumb">Thumb</div>
            <h3>Project 1</h3>
            <p>Project 1 subtitle</p>
            <div class="meta"><span>#1</span><span>Open</span></div>
          </div>
          <div class="face right"  data-slot="1" data-index="1">
            <div class="thumb">Thumb</div>
            <h3>Project 2</h3>
            <p>Project 2 subtitle</p>
            <div class="meta"><span>#2</span><span>Open</span></div>
          </div>
          <div class="face back"   data-slot="2" data-index="2">
            <div class="thumb">Thumb</div>
            <h3>Project 3</h3>
            <p>Project 3 subtitle</p>
            <div class="meta"><span>#3</span><span>Open</span></div>
          </div>
          <div class="face left"   data-slot="3" data-index="3">
            <div class="thumb">Thumb</div>
            <h3>Project 4</h3>
            <p>Project 4 subtitle</p>
            <div class="meta"><span>#4</span><span>Open</span></div>
          </div>
          <div class="face top"    data-slot="top" aria-hidden="true">
            <div style="text-align:center"><h3>Welcome</h3><p style="color:var(--muted)">Drag horizontally</p></div>
          </div>
          <div class="face bottom" data-slot="bottom" aria-hidden="true">
            <div style="text-align:center"><h3>More</h3><p style="color:var(--muted)">Projects below</p></div>
          </div>
        </div>

        <!-- Bento grid overlays the scene but is manipulated by JS to "deform" around cube -->
        <div class="bento" id="bento">
          <div class="bento-grid" id="bentoGrid"></div>
        </div>
      </div>
    </div>

    <div class="project-list">
      <div class="header">
        <div style="font-weight:700">Projects</div>
        <div class="expander" id="expander">Expand</div>
      </div>
      <ul id="projectListUl"></ul>
    </div>
  </div>

  <div class="hint">Drag to rotate • Click a face to open • Cards orbit and deform</div>

<script>
/*
  JS behavior summary:
  - projects[] defines data.
  - cube rotation controlled by cumulative-drag model (no inversion).
  - compute which face is most visible by comparing face normal transformed by cube rotation to camera vector (dot product).
  - Info panels show the most-visible project's details.
  - Bento cards placed in a 3x3 grid; each card's transform is displaced away from the cube in proportion to proximity to cube center and rotY.
  - Click vs drag: short press + small move = click; otherwise rotate.
  - Clicking a card centers cube on that project's slot.
*/

const projects = [
  { title:'Minesweeper', subtitle:'Interactive tile-based puzzle', desc:'Classic rules with a modern UI', url:'/PolyWeave-Mines/', img:null, color:'#e74c3c' },
  { title:'Project 2', subtitle:'Utility tool', desc:'Small utility app demo', url:'#', img:null, color:'#27ae60' },
  { title:'Project 3', subtitle:'Algorithmic art', desc:'Generative visuals', url:'#', img:null, color:'#9b59b6' },
  { title:'Project 4', subtitle:'UX experiments', desc:'Micro interaction set', url:'#', img:null, color:'#1abc9c' },
  // Additional projects for testing infinite cycling
  { title:'Project 5', subtitle:'Extra', desc:'Extra project', url:'#', img:null, color:'#f39c12' },
  { title:'Project 6', subtitle:'Extra 2', desc:'Extra project 2', url:'#', img:null, color:'#34495e' }
];

// initial mapping: front=projects[0], right=projects[1], back=projects[2], left=projects[3]
let frontIndex = 0; // which project index is currently at front slot
const slotCount = 4; // horizontal faces

// DOM refs
const cubeEl = document.getElementById('cube');
const sceneEl = document.getElementById('scene');
const bentoGrid = document.getElementById('bentoGrid');
const titleEl = document.getElementById('projTitle');
const subtitleEl = document.getElementById('projSubtitle');
const descEl = document.getElementById('projDesc');
const imagePanel = document.getElementById('imagePanel');
const projectListUl = document.getElementById('projectListUl');
const expander = document.getElementById('expander');

// populate initial face content (adjacent ascending left->front->right->back)
function seedFaces(){
  const faceEls = cubeEl.querySelectorAll('.face');
  // mapping of slot indices to material positions: front(0), right(1), back(2), left(3)
  // We set data-index attributes to corresponding project indices for initial frontIndex
  const len = projects.length;
  const mapping = {
    front: (frontIndex + 0) % len,
    right: (frontIndex + 1) % len,
    back:  (frontIndex + 2) % len,
    left:  (frontIndex + 3) % len
  };
  faceEls.forEach(f=>{
    const slot = f.dataset.slot;
    if (slot === 'top' || slot === 'bottom') return;
    let idx;
    if(slot==='front') idx = mapping.front;
    else if(slot==='right') idx = mapping.right;
    else if(slot==='back') idx = mapping.back;
    else if(slot==='left') idx = mapping.left;
    f.dataset.index = idx;
    const proj = projects[idx];
    f.querySelector('h3').textContent = proj.title;
    f.querySelector('p').textContent = proj.subtitle;
    const meta = f.querySelector('.meta span');
    // second meta span is static; index display:
    f.querySelector('.meta').children[0].textContent = `#${(idx%projects.length)+1}`;
    // style thumb background using color
    const thumb = f.querySelector('.thumb');
    if(thumb) thumb.style.background = proj.color || '#0b1220';
  });
}
seedFaces();

// make bento cards (3x3 sample; center cell left empty to make room for cube)
function buildBento(){
  bentoGrid.innerHTML = '';
  // We'll build 9 cells but center is transparent to let cube breathe.
  const total = 9;
  for(let i=0;i<total;i++){
    const cell = document.createElement('div');
    // center index 4 is where cube sits — create an empty spacer
    if(i===4){
      const spacer = document.createElement('div');
      spacer.style.width='100%'; spacer.style.height='100%';
      spacer.style.background='transparent'; spacer.style.pointerEvents='none';
      bentoGrid.appendChild(spacer);
      continue;
    }
    const card = document.createElement('div');
    card.className='card';
    // pick project index by order surrounding: compute pick based on cell
    const projIdx = i % projects.length;
    card.dataset.proj = projIdx;
    card.innerHTML = `<div class="thumb">#${projIdx+1}</div>
                      <div class="body"><h4>${projects[projIdx].title}</h4><p>${projects[projIdx].subtitle}</p></div>`;
    bentoGrid.appendChild(card);
    card.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      // center cube on that project's nearest slot
      centerCubeOnProject(projIdx);
    });
  }
}
buildBento();

// populate project list
function buildProjectList(){
  projectListUl.innerHTML='';
  projects.forEach((p,i)=>{
    const li = document.createElement('li');
    li.innerHTML = `<div>${i+1}. ${p.title}</div><div><button data-i="${i}">Open</button></div>`;
    projectListUl.appendChild(li);
    li.querySelector('button').addEventListener('click', ()=> window.open(p.url,'_blank'));
  });
}
buildProjectList();

// expandable
let listOpen=false;
expander.addEventListener('click', ()=>{
  listOpen = !listOpen;
  projectListUl.classList.toggle('open', listOpen);
  expander.textContent = listOpen ? 'Collapse' : 'Expand';
});

// rotation state (degrees)
let rotY = 0; // cube yaw in degrees
let isPointerDown = false;
let startX = 0;
let startTime = 0;
let startRotY = 0;
let angVel = 0;
const SENS = 0.35; // degrees per px
const CLICK_MOVE_THRESHOLD = 6;
const CLICK_TIME_THRESHOLD = 300;

// pointer events: cumulative drag model
sceneEl.addEventListener('pointerdown', (e)=>{
  isPointerDown = true;
  startX = e.clientX;
  startTime = performance.now();
  startRotY = rotY;
  angVel = 0;
  sceneEl.setPointerCapture(e.pointerId);
});
sceneEl.addEventListener('pointermove', (e)=>{
  if(!isPointerDown) return;
  const dx = e.clientX - startX;
  const target = startRotY + dx * SENS;
  angVel = target - rotY;
  rotY = target;
  applyRotation();
});
sceneEl.addEventListener('pointerup', (e)=>{
  sceneEl.releasePointerCapture(e.pointerId);
  const dt = performance.now() - startTime;
  const moved = Math.hypot(e.clientX - startX, e.clientY - startX);
  const isClick = moved <= CLICK_MOVE_THRESHOLD && dt <= CLICK_TIME_THRESHOLD;
  isPointerDown = false;
  angVel = Math.max(-20, Math.min(20, angVel));
  if(isClick){
    // element at point
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const face = el && el.closest && el.closest('.face');
    if(face && face.dataset.index !== undefined){
      const idx = Number(face.dataset.index);
      const p = projects[idx];
      if(p && p.url) window.open(p.url,'_blank');
    }
  }
});

// apply CSS transform and keep faces' data updated when back-slot crosses
function applyRotation(){
  cubeEl.style.transform = `translateZ(-200px) rotateX(-12deg) rotateY(${rotY}deg)`;
  updateFacesWhenHidden();
  updateInfoByVisibility();
  deformBento();
}

// compute which slot is currently at approximate front by mapping rotY to nearest 90deg step
function computeFrontSlotFromRot(){
  // normalize -rotY because visual rotation opposite sign
  const angle = ((-rotY % 360) + 360) % 360;
  // divide into 4 sectors (0 front, 90 right, 180 back, 270 left)
  const q = Math.round(angle / 90) % 4;
  return ((q%4)+4)%4; // 0..3
}

// update faces mapping when a face goes to back (hidden) to swap new project into that hidden slot
let lastBackSlot = computeBackSlotFromRot();
function computeBackSlotFromRot(){
  return (computeFrontSlotFromRot() + 2) % 4;
}
function updateFacesWhenHidden(){
  const currentBack = computeBackSlotFromRot();
  if(currentBack !== lastBackSlot){
    // determine direction (modular)
    const delta = ((currentBack - lastBackSlot) + 4)%4;
    let step=0;
    if(delta===1) step=1;
    else if(delta===3) step=-1;
    else if(delta===2) step = angVel>0 ? 2 : -2;
    if(step!==0){
      frontIndex = ((frontIndex + step) % projects.length + projects.length)%projects.length;
      // re-seed face element data
      seedFaces();
    }
    lastBackSlot = currentBack;
  }
}

// given cube rotation, compute visibility score for each face (approx using dot product of face normal and camera vector)
function updateInfoByVisibility(){
  // camera in CSS world is at some fixed position; we approximate camera vector in cube space as (0,0,1) looking toward +Z in object space,
  // but because we rotate cube, we transform each face normal by cube's rotation and compute dot(normal, cameraVec).
  // Implementation: for each slot (front,right,back,left) compute angle difference between slot angle and -rotY.
  const angleRad = (rotY * Math.PI)/180;
  // For 4 horizontal slots compute cos(angleDiff) where slotAngles are 0,-90,-180,-270 degrees in radians (matching front/right/back/left)
  const slotAngles = [0, -Math.PI/2, -Math.PI, -3*Math.PI/2];
  const visScores = slotAngles.map(sa=>{
    // visual angle difference = normalize(-rotYRad - sa)
    let diff = normalizeAngleRad(-angleRad - sa);
    // visibility approximated by cos(diff) but make negative -> 0
    const score = Math.max(0, Math.cos(diff));
    return score;
  });
  // pick highest
  let bestSlot = 0; let bestScore = -1;
  for(let i=0;i<4;i++){
    if(visScores[i] > bestScore){ bestScore = visScores[i]; bestSlot = i; }
  }
  // bestSlot maps to project index (frontIndex + bestSlot)
  const projIdx = (frontIndex + bestSlot) % projects.length;
  const p = projects[projIdx];
  if(p){
    // update panels
    titleEl.textContent = p.title;
    subtitleEl.textContent = p.subtitle;
    descEl.textContent = p.desc;
    imagePanel.textContent = p.img ? '' : `${p.title} preview (no image)`; // plug image when available
    imagePanel.style.borderLeft = `4px solid ${p.color || '#2f9bd8'}`;
  }
}

// helper normalize radian angle to [-PI, PI)
function normalizeAngleRad(a){
  const two = Math.PI*2;
  let v = (a + Math.PI) % two;
  if(v < 0) v += two;
  return v - Math.PI;
}

// Bento deformation: push cards outward based on cube rotation; keeps center empty
function deformBento(){
  // pick cards in bentoGrid
  const cards = Array.from(bentoGrid.querySelectorAll('.card'));
  // compute a small displacement for each card based on its index and rotY
  const rot = (rotY % 360) * (Math.PI/180);
  cards.forEach((card, i)=>{
    // position in grid: approximate center offset (-1..1, -1..1)
    // derive row/col from index while skipping center cell mapping used earlier:
    // bento grid children length is 9 but index 4 was spacer, our cards appended in non-spacer positions; compute layout cell
    const nodeIndex = i >= 4 ? i+1 : i; // map to 0..8 skipping 4
    const col = nodeIndex % 3 - 1; // -1,0,1
    const row = Math.floor(nodeIndex/3)-1; // -1,0,1
    // base transform: translate outward away from cube center (col,row)
    const distance = 18 + (Math.abs(col)+Math.abs(row))*6;
    // add rotation-dependent horizontal offset so cards "follow" cube rotation
    const xOffset = Math.sin(rot + col*0.4)*distance;
    const yOffset = Math.cos(rot + row*0.2)* (distance*0.35);
    const scale = 1 + (Math.max(0, 1 - Math.hypot(col, row)))*0.03;
    card.style.transform = `translate3d(${xOffset}px, ${yOffset}px, 0) scale(${scale})`;
  });
}

// center cube on a project index by animating rotY so that that project is at front slot
function centerCubeOnProject(projIdx){
  // find a slot (0..3) where this project currently sits relative to frontIndex
  // we want projIdx to end up at front (slot 0) -> so compute required step
  // determine current slot of projIdx: slot = (projIdx - frontIndex) mod slotCount
  const slot = ((projIdx - frontIndex) % slotCount + slotCount) % slotCount; // 0..3
  // desired angle for that slot: slotAnglesDegrees = [0, -90, -180, -270], so to bring slot to front we rotate by -slot*90 degrees relative to current rot
  const desiredRel = -slot * 90; // degrees to rotate relative to current logical orientation
  const currentAngleNormalized = ((rotY%360)+360)%360;
  // compute target rotation such that current front logical becomes equal to desired relative shift
  // easiest: compute target rotY so that computeFrontSlotFromRot() equals desired front slot (0). We'll rotate by nearest multiple.
  // The cube front corresponds to rotY ≈ 0 deg for frontIndex as-is. We'll compute the target absolute rotation:
  const target = rotY + desiredRel;
  // animate rotY from current to target using easing
  animateRotationTo(target, 420);
}

// simple rotation animator
function animateRotationTo(targetDeg, duration=420){
  const start = performance.now();
  const from = rotY;
  function step(ts){
    const t = Math.min(1, (ts-start)/duration);
    const eased = 1 - Math.pow(1-t,3); // easeOutCubic
    rotY = from + (targetDeg - from)*eased;
    applyRotation();
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// initial render state
applyRotation();
deformBento();
updateInfoByVisibility();

// build project list visuals done earlier; also set click listeners on cards for centering
Array.from(document.querySelectorAll('.card')).forEach(c=>{
  c.addEventListener('click', (ev)=>{
    const pi = Number(c.dataset.proj);
    centerCubeOnProject(pi);
  });
});

// face click opens project
Array.from(document.querySelectorAll('.face')).forEach(f=>{
  f.addEventListener('click', (ev)=>{
    // find project for that face (dataset.index)
    const idx = Number(f.dataset.index);
    if(!Number.isNaN(idx) && projects[idx] && projects[idx].url) window.open(projects[idx].url,'_blank');
  });
});

// inertia loop for smooth spin when released
let lastT = performance.now();
function loop(now){
  const dt = (now - lastT)/1000; lastT = now;
  if(!isPointerDown && Math.abs(angVel) > 0.0005){
    rotY += angVel;
    angVel *= Math.pow(0.90, dt*60); // damping
    applyRotation();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Optional: load /projects.json and replace projects; non-blocking
(async function tryLoadJSON(){
  try{
    const res = await fetch('/projects.json', {cache:'no-store'});
    if(!res.ok) return;
    const data = await res.json();
    if(!Array.isArray(data) || data.length===0) return;
    projects.length=0;
    data.forEach(p=> projects.push({
      title:p.title||p.name||'Untitled',
      subtitle:p.subtitle||p.snippet||p.description||'',
      desc:p.desc||p.description||'',
      url:p.url||p.link||'#',
      img:p.img||p.image||null,
      color:p.color||'#2f9bd8'
    }));
    // re-seed faces and UI
    seedFaces(); buildBento(); buildProjectList();
    updateInfoByVisibility();
  }catch(e){ /* ignore */ }
})();
</script>
</body>
</html>
