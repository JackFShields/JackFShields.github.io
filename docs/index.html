<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Portfolio Cube with Panel Bites</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root{
      --bg: #0a0f1b;
      --panel: rgba(255,255,255,0.03);
      --border: rgba(255,255,255,0.06);
      --text: #e6eef6;
      --muted: rgba(255,255,255,0.6);
      --cube-radius: 180px;   /* radius of the visible circular footprint of the cube */
      --bite-offset: 14px;    /* how much the bite overlaps panel edge visually */
    }

    html,body{height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .page {
      min-height:100vh;
      display:grid;
      grid-template-columns: 320px minmax(420px,640px) 320px;
      grid-template-rows: auto 1fr auto;
      gap:24px;
      align-items:start;
      padding:36px;
    }

    /* Panels that get bitten by the circular footprint */
    .panel {
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:18px;
      position:relative;
      overflow:visible;
      transition:box-shadow .18s ease, transform .16s ease;
    }
    .panel h1{font-size:22px;margin-bottom:8px}
    .panel p{color:var(--muted);line-height:1.5}

    /* The bite is implemented as a pseudo element positioned relative to each panel
       JS will set --bite-x and --bite-y (px offsets relative to panel's top-left) and --bite-visible (0/1).
       Width/height derived from --cube-radius + offset so coverage is consistent.
    */
    .panel::after {
      content:'';
      position:absolute;
      width:calc(var(--cube-radius) * 2 + var(--bite-offset) * 2);
      height:calc(var(--cube-radius) * 2 + var(--bite-offset) * 2);
      left: var(--bite-x, -9999px);
      top: var(--bite-y, -9999px);
      transform: translate(-50%,-50%);
      border-radius:50%;
      background:var(--bg);
      pointer-events:none;
      opacity: calc(var(--bite-visible, 0));
      transition: left .12s linear, top .12s linear, opacity .18s linear;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.01);
      z-index:6;
    }

    /* Layout placements */
    .title-panel { grid-column:1; grid-row:1; }
    .desc-panel  { grid-column:1; grid-row:2; min-height:140px; margin-top:10px; }
    .image-panel { grid-column:3; grid-row:1 / span 2; display:flex; align-items:center; justify-content:center; min-height:300px; }

    /* Center cube area */
    .center {
      grid-column:2;
      grid-row:1 / span 2;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      padding:10px;
    }

    .scene {
      width: calc(var(--cube-radius) * 2);
      height: calc(var(--cube-radius) * 2);
      position:relative;
      perspective:1100px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action:none;
    }

    /* Circular footprint that visually occludes panels (placed above panels, under cube) */
    .footprint {
      position:absolute;
      width: calc(var(--cube-radius) * 2);
      height: calc(var(--cube-radius) * 2);
      border-radius:50%;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:transparent;
      z-index:4; /* above panels but below cube */
      pointer-events:none;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }

    /* Cube visual (CSS 3D mock) */
    .cube {
      width: calc(var(--cube-radius) * 2);
      height: calc(var(--cube-radius) * 2);
      position:relative;
      transform-style:preserve-3d;
      transform: translateZ(-120px) rotateX(-8deg) rotateY(0deg);
      z-index:5; /* above footprint and panels */
      transition: transform .08s linear;
    }

    .face {
      position:absolute; width:100%; height:100%; left:0; top:0;
      display:flex; align-items:center; justify-content:center; flex-direction:column;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:14px; border:1px solid var(--border);
      box-shadow: 0 10px 34px rgba(2,6,23,0.6);
      backface-visibility:hidden;
      cursor:pointer;
    }

    .face h3{font-size:26px;margin-bottom:6px}
    .face p{color:var(--muted)}

    /* Face transforms (visual only) */
    .front { transform: rotateY(0deg) translateZ(calc(var(--cube-radius))); }
    .right { transform: rotateY(90deg) translateZ(calc(var(--cube-radius))); }
    .back  { transform: rotateY(180deg) translateZ(calc(var(--cube-radius))); }
    .left  { transform: rotateY(-90deg) translateZ(calc(var(--cube-radius))); }

    /* small controls row */
    .controls {
      grid-column:2;
      grid-row:3;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-top:12px;
    }
    .btn { background:var(--panel); border:1px solid var(--border); padding:8px 12px; border-radius:8px; cursor:pointer; color:var(--muted) }

    @media (max-width:900px){
      .page { grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; padding:18px; gap:16px; }
      .title-panel, .desc-panel, .image-panel { grid-column:1; grid-row:auto; }
      .center { grid-column:1; grid-row:auto; order:2 }
      .footprint { left:50%; top:50%; transform:translate(-50%,-50%) scale(0.9); }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="panel title-panel" id="titlePanel">
      <h1 id="projTitle">Minesweeper</h1>
      <p id="projSubtitle">Interactive tile-based puzzle</p>
    </div>

    <div class="panel desc-panel" id="descPanel">
      <p id="projDesc">Click or drag the cube. Title, description and image will show the face that is most visible; the cube carves a circular bite into these panels when they get close.</p>
    </div>

    <div class="panel image-panel" id="imagePanel">Minesweeper preview (no image)</div>

    <div class="center">
      <div class="scene" id="scene" aria-label="3D cube scene">
        <div class="footprint" id="footprint" aria-hidden="true"></div>
        <div class="cube" id="cube" role="application" aria-label="rotating cube">
          <div class="face front" data-slot="front" data-index="0">
            <h3>Project 1</h3><p>Interactive tile-based puzzle</p>
          </div>
          <div class="face right" data-slot="right" data-index="1">
            <h3>Project 2</h3><p>Utility tool</p>
          </div>
          <div class="face back" data-slot="back" data-index="2">
            <h3>Project 3</h3><p>Algorithmic art</p>
          </div>
          <div class="face left" data-slot="left" data-index="3">
            <h3>Project 4</h3><p>UX experiments</p>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="btn" id="expandBtn">Expand</div>
      <div class="btn" id="hint">Drag to rotate â€¢ Click a face to open</div>
    </div>
  </div>

  <script>
    /*
      Implementation notes:
      - Panels (title, desc, image) receive a circular "bite" pseudo-element positioned where the panel intersects the cube's circular footprint.
      - JS computes the footprint center on-screen and for each panel calculates the closest point on the panel rect to that center.
      - If that closest point lies within the footprint radius + a small margin, we set CSS vars --bite-x/--bite-y relative to the panel so the ::after displays the bite.
      - Cube rotation is handled by cumulative-drag so starting pointer position behind the cube won't invert direction.
      - Visibility heuristic (angle-based) chooses which horizontal face is "most visible" and updates the panels accordingly.
    */

    const projects = [
      { title:'Minesweeper', subtitle:'Interactive tile-based puzzle', desc:'Classic minesweeper with a modern UI', url:'/PolyWeave-Mines/', color:'#e74c3c' },
      { title:'Project 2', subtitle:'Utility tool', desc:'Small utility app demo', url:'#', color:'#27ae60' },
      { title:'Project 3', subtitle:'Algorithmic art', desc:'Generative visuals', url:'#', color:'#9b59b6' },
      { title:'Project 4', subtitle:'UX experiments', desc:'Micro interactions', url:'#', color:'#1abc9c' }
    ];

    // DOM refs
    const scene = document.getElementById('scene');
    const cube = document.getElementById('cube');
    const footprint = document.getElementById('footprint');
    const titlePanel = document.getElementById('titlePanel');
    const descPanel = document.getElementById('descPanel');
    const imagePanel = document.getElementById('imagePanel');
    const projTitle = document.getElementById('projTitle');
    const projSubtitle = document.getElementById('projSubtitle');
    const projDesc = document.getElementById('projDesc');
    const expandBtn = document.getElementById('expandBtn');

    const CUBE_RADIUS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cube-radius')) || 180;
    const BITE_OFFSET = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bite-offset')) || 14;

    // initial face mapping: front=0, right=1, back=2, left=3
    let frontIndex = 0;

    // seed face text from projects
    function seedFaces(){
      const faces = cube.querySelectorAll('.face');
      const len = projects.length;
      const mapping = {
        front: (frontIndex + 0) % len,
        right: (frontIndex + 1) % len,
        back:  (frontIndex + 2) % len,
        left:  (frontIndex + 3) % len
      };
      faces.forEach(f=>{
        const slot = f.dataset.slot;
        if(slot === 'front') idx = mapping.front;
        else if(slot === 'right') idx = mapping.right;
        else if(slot === 'back') idx = mapping.back;
        else if(slot === 'left') idx = mapping.left;
        const p = projects[idx];
        f.dataset.index = idx;
        f.querySelector('h3').textContent = p.title;
        f.querySelector('p').textContent = p.subtitle;
      });
    }
    seedFaces();

    // compute footprint center on screen
    function getFootprintCenter(){
      const r = footprint.getBoundingClientRect();
      return { x: r.left + r.width/2, y: r.top + r.height/2, radius: Math.min(r.width, r.height)/2 };
    }

    // for a given panel element, compute closest point on panel rect to footprint center
    // set CSS variables --bite-x/--bite-y (px relative to panel) and --bite-visible (1/0)
    function updatePanelBite(panelEl){
      const panelRect = panelEl.getBoundingClientRect();
      const fp = getFootprintCenter();
      // closest point on panel rect to circle center
      const closestX = Math.max(panelRect.left, Math.min(fp.x, panelRect.right));
      const closestY = Math.max(panelRect.top, Math.min(fp.y, panelRect.bottom));
      const dx = closestX - fp.x;
      const dy = closestY - fp.y;
      const dist = Math.hypot(dx, dy);
      const margin = 6; // give a small gap so bite looks natural
      if(dist < fp.radius + margin){
        // set local coordinates for bite center relative to panel
        const localX = closestX - panelRect.left;
        const localY = closestY - panelRect.top;
        panelEl.style.setProperty('--bite-x', `${localX}px`);
        panelEl.style.setProperty('--bite-y', `${localY}px`);
        panelEl.style.setProperty('--bite-visible', '1');
      } else {
        panelEl.style.setProperty('--bite-visible', '0');
        // push offscreen to avoid flicker
        panelEl.style.setProperty('--bite-x', `-9999px`);
        panelEl.style.setProperty('--bite-y', `-9999px`);
      }
    }

    // update all three panels
    function updateAllBites(){
      updatePanelBite(titlePanel);
      updatePanelBite(descPanel);
      updatePanelBite(imagePanel);
    }

    // rotation state
    let rotY = 0;
    let isDown = false, startX = 0, startRot = 0, startT = 0, angVel = 0;
    const SENS = 0.35;
    const CLICK_MOVE_THRESHOLD = 6;
    const CLICK_TIME_THRESHOLD = 300;

    scene.addEventListener('pointerdown', (e) => {
      isDown = true;
      startX = e.clientX;
      startRot = rotY;
      startT = performance.now();
      angVel = 0;
      scene.setPointerCapture(e.pointerId);
    });

    scene.addEventListener('pointermove', (e) => {
      if(!isDown) return;
      const dx = e.clientX - startX;
      const target = startRot + dx * SENS;
      angVel = target - rotY;
      rotY = target;
      applyRotation();
    });

    scene.addEventListener('pointerup', (e) => {
      try { scene.releasePointerCapture(e.pointerId); } catch {}
      const dt = performance.now() - startT;
      const moved = Math.hypot(e.clientX - startX, e.clientY - startX);
      const isClick = moved <= CLICK_MOVE_THRESHOLD && dt <= CLICK_TIME_THRESHOLD;
      isDown = false;
      angVel = Math.max(-20, Math.min(20, angVel));
      if(isClick){
        // try to open clicked face
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const face = el && el.closest && el.closest('.face');
        if(face){
          const idx = Number(face.dataset.index);
          if(!isNaN(idx) && projects[idx] && projects[idx].url) window.open(projects[idx].url, '_blank');
        }
      }
    });

    // apply cube rotation and update related UI
    function applyRotation(){
      cube.style.transform = `translateZ(-120px) rotateX(-8deg) rotateY(${rotY}deg)`;
      updateMostVisibleFace();
      // footprint static; bite positions rely on layout only
      updateAllBites();
      // update face-cycling when a hidden face passes (simple modular approach not implemented here unless infinite cycling is desired)
    }

    // determine most visible horizontal face by angle heuristic and update panels
    function updateMostVisibleFace(){
      const rad = rotY * Math.PI / 180;
      // slot angles for visual positions (front=0, right=-90deg, back=180deg, left=90deg)
      const slotAngles = [0, -Math.PI/2, Math.PI, Math.PI/2];
      const scores = slotAngles.map(sa => {
        const diff = normalizeAngleRad(-rad - sa);
        return Math.max(0, Math.cos(diff));
      });
      let best = -1, bestSlot = 0;
      scores.forEach((s,i)=>{ if(s>best){ best=s; bestSlot=i; } });
      // map bestSlot to project index using frontIndex mapping (frontIndex currently 0)
      const projIndex = (frontIndex + bestSlot) % projects.length;
      const p = projects[projIndex];
      if(p){
        projTitle.textContent = p.title;
        projSubtitle.textContent = p.subtitle;
        projDesc.textContent = p.desc;
        imagePanel.textContent = `${p.title} preview (no image)`;
        imagePanel.style.borderLeft = `4px solid ${p.color}`;
      }
    }

    // helper normalize radian angle to [-PI, PI)
    function normalizeAngleRad(a){
      const two = Math.PI * 2;
      let v = (a + Math.PI) % two;
      if(v < 0) v += two;
      return v - Math.PI;
    }

    // simple inertia loop
    let last = performance.now();
    function tick(now){
      const dt = (now - last)/1000; last = now;
      if(!isDown && Math.abs(angVel) > 0.0005){
        rotY += angVel;
        angVel *= Math.pow(0.92, dt*60);
        applyRotation();
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // recompute bite positions on resize and load
    function recompute(){
      // ensure footprint centered over cube element (CSS does this visually)
      updateAllBites();
      updateMostVisibleFace();
    }
    window.addEventListener('resize', recompute);
    window.addEventListener('load', ()=>{ recompute(); setTimeout(recompute,120); });

    // face click opens project (handles mouse clicks too)
    Array.from(document.querySelectorAll('.face')).forEach(face=>{
      face.addEventListener('click', ()=> {
        const idx = Number(face.dataset.index);
        if(!isNaN(idx) && projects[idx] && projects[idx].url) window.open(projects[idx].url,'_blank');
      });
    });

    // expand control placeholder
    expandBtn.addEventListener('click', ()=> {
      expandBtn.textContent = expandBtn.textContent === 'Expand' ? 'Collapse' : 'Expand';
      // expand behavior for project list can be implemented here
    });

    // initial render
    applyRotation();
    recompute();
  </script>
</body>
</html>
