<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Portfolio â€” Cube with Smooth Single Bite</title>
<style>
  :root{
    --bg:#071425;
    --panel-grad: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.01));
    --panel-bg: rgba(255,255,255,0.03);
    --border: rgba(255,255,255,0.08);
    --text:#e6eef6;
    --muted: rgba(190,215,240,0.70);
    --gap: 2vw;

    --cube-size: 220px;   /* base cube size */
    --bite-radius: 140px; /* visual bite radius (px) */
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .viewport{width:100vw;height:100vh;position:relative;overflow:hidden}

/* Panels */
  .panel{
    position:absolute;
    background:var(--panel-grad);
    border:1px solid var(--border);
    border-radius:14px;
    padding:22px;
    box-shadow:0 10px 36px rgba(0,0,0,0.35);
    overflow:visible;
    z-index:1;
  }

  .title{ left:2vw; top:2vh; width:calc(42vw - var(--gap)); height:36vh; }
  .title h1{font-size:32px;margin-bottom:8px}
  .title p{color:var(--muted)}

  .description{ left:2vw; top:calc(2vh + 36vh + var(--gap)); width:calc(42vw - var(--gap)); height:calc(82vh - 36vh - var(--gap) - 2vh); }
  .description p{ color:var(--muted); line-height:1.45 }

  .image{ right:2vw; top:2vh; width:54vw; height:80vh; display:flex;align-items:center;justify-content:center;color:var(--muted);text-align:center }

/* Invisible footprint anchor (not shown) - used for positioning bite and cube */
  .footprint-anchor{
    position:absolute;
    left: calc(42vw - var(--gap)/2);
    top: 50%;
    width: calc(var(--bite-radius) * 2);
    height: calc(var(--bite-radius) * 2);
    transform: translate(-50%,-50%);
    pointer-events:none;
    z-index:2;
    opacity:0;
  }

/* SVG overlay that draws one single circular 'bite' visually.
   It's placed above panels (so it hides them where it overlaps) and below cube (so cube is visible).
   The circle is filled with page background to visually remove underlying panel parts, and
   includes a stroke + inner subtle shadow so the border and shadow continuity reads correctly.
*/
  .bite-svg {
    position:absolute;
    left:0;top:0;width:100%;height:100%;
    pointer-events:none;
    z-index:3;
  }

/* Cube sits centered at the footprint anchor (same center), above the bite overlay */
  .cube-wrap{
    position:absolute;
    left: calc(42vw - var(--gap)/2);
    top: 50%;
    transform: translate(-50%,-50%);
    width:var(--cube-size);
    height:var(--cube-size);
    z-index:4;
    pointer-events:none;
  }

  .scene{ width:100%; height:100%; perspective:1000px; pointer-events:auto; user-select:none; touch-action:none; position:relative; }
  .cube { width:100%; height:100%; transform-style:preserve-3d; transform: translateZ(-90px) rotateX(-10deg) rotateY(0deg); transition:transform .08s linear; position:relative; z-index:5; }
  .face{
    position:absolute; left:0; top:0; width:100%; height:100%;
    border-radius:10px; background:var(--panel-grad); border:1px solid var(--border);
    display:flex;align-items:center;justify-content:center;flex-direction:column; backface-visibility:hidden; box-shadow: 0 10px 36px rgba(0,0,0,0.6);
    cursor:pointer;
  }
  .face h3{font-size:20px;margin:0 0 6px 0}
  .front{ transform: rotateY(0deg) translateZ(calc(var(--cube-size)/2)); }
  .right{ transform: rotateY(90deg) translateZ(calc(var(--cube-size)/2)); }
  .back{ transform: rotateY(180deg) translateZ(calc(var(--cube-size)/2)); }
  .left{ transform: rotateY(270deg) translateZ(calc(var(--cube-size)/2)); }
  .top{ transform: rotateX(90deg) translateZ(calc(var(--cube-size)/2)); }
  .bottom{ transform: rotateX(-90deg) translateZ(calc(var(--cube-size)/2)); }

/* Project buttons row: wraps when needed, taller rectangular ratio ~3:5 */
  .projects {
    position:absolute; left:0; right:0; bottom:0;
    display:flex; gap:14px; padding:2vh 2vw; flex-wrap:wrap; justify-content:center; align-items:center;
    background: linear-gradient(to top, rgba(0,0,0,0.45), transparent);
    z-index:6;
  }
  .proj-btn {
    width:140px; height:84px; background:var(--panel-grad); border:1px solid var(--border); border-radius:10px;
    display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; transition:transform .18s, box-shadow .18s;
  }
  .proj-btn:hover{ transform:translateY(-6px); box-shadow:0 12px 30px rgba(0,0,0,0.45) }

/* responsive tweaks */
  @media (max-width:980px){
    :root{ --cube-size:200px; --bite-radius:120px }
    .title, .description { left:2vw; width:calc(100% - 4vw) }
    .title{ top:2vh; height:20vh }
    .description{ top:calc(2vh + 20vh + var(--gap)); height:28vh }
    .image{ left:2vw; right:2vw; top:calc(2vh + 20vh + 28vh + calc(var(--gap)*2)); width:calc(100% - 4vw); height:32vh }
    .cube-wrap{ left:50%; top:calc(2vh + 20vh + (28vh/2)); transform:translate(-50%,-50%) }
    .footprint-anchor{ left:50%; top:calc(2vh + 20vh + (28vh/2)); transform:translate(-50%,-50%) }
  }
</style>
</head>
<body>
  <div class="viewport">
    <div class="panel title" id="titlePanel">
      <h1 id="projTitle">Minesweeper</h1>
      <p id="projSubtitle">Interactive tile-based puzzle</p>
    </div>

    <div class="panel description" id="descPanel">
      <p id="projDesc">Classic minesweeper rebuilt with modern UI and board sizes. Drag the cube or click a face to select projects.</p>
    </div>

    <div class="panel image" id="imagePanel">Minesweeper preview (no image)</div>

    <!-- anchor used to compute the single bite center; invisible -->
    <div class="footprint-anchor" id="anchor"></div>

    <!-- SVG overlay that paints one single circular bite with stroke + inner shadow.
         Circle fill matches page bg so underlying panels visually disappear where it overlaps.
         The stroke + inner shadow emulate the panel border and inner shading so the cut reads continuous.
    -->
    <svg class="bite-svg" id="biteSVG" aria-hidden="true">
      <defs>
        <!-- inner shadow filter for the bite rim -->
        <filter id="innerShadow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="blur" />
          <feOffset dx="0" dy="6" result="offsetBlur" />
          <feComposite in="offsetBlur" in2="SourceAlpha" operator="arithmetic" k2="-1" k3="1" result="innerShadow"/>
          <feColorMatrix in="innerShadow" type="matrix" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0   0 0 0 0.35" result="shadow"/>
          <feMerge>
            <feMergeNode in="shadow" />
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- circle (dynamic) -->
      <circle id="biteCircle" cx="0" cy="0" r="0"
              fill="var(--bg, #071425)"
              stroke="rgba(255,255,255,0.08)" stroke-width="2"
              filter="url(#innerShadow)"/>
    </svg>

    <!-- cube sits exactly centered over anchor -->
    <div class="cube-wrap" id="cubeWrap">
      <div class="scene" id="scene">
        <div class="cube" id="cube" role="application" aria-label="interactive cube">
          <div class="face front" data-slot="front"><h3>Project 1</h3><p>Interactive tile puzzle</p></div>
          <div class="face right" data-slot="right"><h3>Project 2</h3><p>Utility tool</p></div>
          <div class="face back" data-slot="back"><h3>Project 3</h3><p>Algorithmic art</p></div>
          <div class="face left" data-slot="left"><h3>Project 4</h3><p>UX experiments</p></div>
          <div class="face top" data-slot="top"><h3>Project 5</h3><p>Top face</p></div>
          <div class="face bottom" data-slot="bottom"><h3>Project 6</h3><p>Bottom face</p></div>
        </div>
      </div>
    </div>

    <div class="projects" id="projectsBar"></div>
  </div>

<script>
/* Projects data */
const projects = [
  { title:'Minesweeper', subtitle:'Interactive tile-based puzzle', desc:'Classic minesweeper rebuilt with modern UI', url:'#', color:'#e74c3c' },
  { title:'Project 2', subtitle:'Utility tool', desc:'Small utility demo', url:'#', color:'#27ae60' },
  { title:'Project 3', subtitle:'Algorithmic art', desc:'Generative visuals', url:'#', color:'#9b59b6' },
  { title:'Project 4', subtitle:'UX experiments', desc:'Micro interactions', url:'#', color:'#1abc9c' },
  { title:'Project 5', subtitle:'Extra', desc:'Extra project', url:'#', color:'#f39c12' },
  { title:'Project 6', subtitle:'Extra 2', desc:'Extra project 2', url:'#', color:'#34495e' }
];

/* DOM refs */
const anchor = document.getElementById('anchor');
const biteSVG = document.getElementById('biteSVG');
const biteCircle = document.getElementById('biteCircle');
const cubeWrap = document.getElementById('cubeWrap');
const scene = document.getElementById('scene');
const cube = document.getElementById('cube');
const titlePanel = document.getElementById('titlePanel');
const descPanel = document.getElementById('descPanel');
const imagePanel = document.getElementById('imagePanel');
const projectsBar = document.getElementById('projectsBar');

/* Build projects (wrap capable) */
function renderProjects(){
  projectsBar.innerHTML = '';
  projects.forEach((p,i)=>{
    const btn = document.createElement('div');
    btn.className = 'proj-btn';
    btn.innerHTML = `<strong>${i+1}</strong><span style="color:var(--muted);font-size:12px;margin-top:6px">${p.title}</span>`;
    btn.addEventListener('click', ()=> centerCubeOnProject(i));
    projectsBar.appendChild(btn);
  });
}
renderProjects();

/* compute anchor center and radius (based on anchor bounding rect) */
function computeAnchor(){
  const r = anchor.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2, r: Math.min(r.width, r.height)/2 };
}

/* position the bite SVG circle to visually cut panels; also update bite for panels (for interactive state if needed) */
function positionBite(){
  const a = computeAnchor();
  // place bite SVG circle (SVG uses page coords relative to viewport)
  biteCircle.setAttribute('cx', a.x);
  biteCircle.setAttribute('cy', a.y);
  biteCircle.setAttribute('r', a.r);
  // size SVG to full viewport (already set) but ensure it's sized correctly for coord system
  biteSVG.style.width = `${window.innerWidth}px`;
  biteSVG.style.height = `${window.innerHeight}px`;
  // update panels' internal pseudo decorations to align rim highlight if desired
  // set CSS vars for pseudo-elements (used earlier approach)
  [titlePanel, descPanel, imagePanel].forEach(el=>{
    const rect = el.getBoundingClientRect();
    // compute closest point on rect to anchor center
    const cx = Math.max(rect.left, Math.min(a.x, rect.right));
    const cy = Math.max(rect.top, Math.min(a.y, rect.bottom));
    const localX = Math.round(cx - rect.left);
    const localY = Math.round(cy - rect.top);
    el.style.setProperty('--bite-x', `${localX}px`);
    el.style.setProperty('--bite-y', `${localY}px`);
    el.style.setProperty('--bite-radius', `${a.r}px`);
    // show/hide panel's decorative pseudo if intersecting
    const dist = Math.hypot(cx - a.x, cy - a.y);
    const margin = 6;
    if(dist < a.r + margin){
      el.style.setProperty('--bite-visible','1');
      el.setAttribute('data-bite','1');
    } else {
      el.style.setProperty('--bite-visible','0');
      el.setAttribute('data-bite','0');
    }
  });
}

/* Place cubeWrap center to anchor center (ensure exact overlap on resize) */
function positionCubeWrap(){
  const a = computeAnchor();
  cubeWrap.style.left = `${(a.x)}px`;
  cubeWrap.style.top = `${(a.y)}px`;
  // cubeWrap uses transform translate(-50%,-50%) in CSS; set directly:
  cubeWrap.style.transform = 'translate(-50%,-50%)';
}

/* Responsive startup */
function layoutUpdate(){
  // reposition anchor if CSS changed; anchor is at CSS position; computeAnchor reads it
  positionBite();
  positionCubeWrap();
}

/* cube rotation (drag) with inertia */
let rotY = 0;
let isDown = false, startX = 0, startRot = 0, startT = 0, angVel = 0;
const SENS = 0.35, CLICK_MOVE_THRESHOLD = 6, CLICK_TIME_THRESHOLD = 300;

scene.addEventListener('pointerdown', e=>{
  isDown = true; startX = e.clientX; startRot = rotY; startT = performance.now(); angVel = 0;
  scene.setPointerCapture(e.pointerId);
});
scene.addEventListener('pointermove', e=>{
  if(!isDown) return;
  const dx = e.clientX - startX;
  const target = startRot + dx * SENS;
  angVel = target - rotY; rotY = target; applyRotation();
});
scene.addEventListener('pointerup', e=>{
  try{ scene.releasePointerCapture(e.pointerId); }catch{}
  const dt = performance.now() - startT; const moved = Math.hypot(e.clientX - startX, e.clientY - startX);
  const isClick = moved <= CLICK_MOVE_THRESHOLD && dt <= CLICK_TIME_THRESHOLD;
  isDown = false; angVel = Math.max(-20, Math.min(20, angVel));
  if(isClick){
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const face = el && el.closest && el.closest('.face');
    if(face) openFaceProject(face);
  }
});

function applyRotation(){
  cube.style.transform = `translateZ(-90px) rotateX(-10deg) rotateY(${rotY}deg)`;
  updateMostVisibleFace();
  // bite remains static relative to layout (cube rotates in place)
}

/* face visibility heuristic (angle-based) */
function updateMostVisibleFace(){
  const rad = rotY * Math.PI / 180;
  const slotAngles = [0, -Math.PI/2, Math.PI, Math.PI/2]; // front,right,back,left
  const scores = slotAngles.map(sa=>{
    const diff = normalizeAngleRad(-rad - sa);
    return Math.max(0, Math.cos(diff));
  });
  let best = -1, bestIdx = 0;
  scores.forEach((s,i)=>{ if(s>best){ best=s; bestIdx=i }});
  const mapping = [0,1,2,3]; // simple mapping front->proj0...
  const projIndex = mapping[bestIdx] % projects.length;
  const p = projects[projIndex];
  if(p){
    document.getElementById('projTitle').textContent = p.title;
    document.getElementById('projSubtitle').textContent = p.subtitle;
    document.getElementById('projDesc').textContent = p.desc;
    document.getElementById('imagePanel').textContent = `${p.title} preview (no image)`;
    document.getElementById('imagePanel').style.borderLeft = `4px solid ${p.color}`;
  }
}
function normalizeAngleRad(a){
  const two = Math.PI*2; let v = (a + Math.PI) % two; if(v < 0) v += two; return v - Math.PI;
}

/* center cube so project index is at front slot */
function centerCubeOnProject(idx){
  const slot = idx % 4;
  const target = rotY + (-slot * 90);
  animateRotationTo(target, 420);
}
function animateRotationTo(targetDeg, duration=420){
  const start = performance.now(), from = rotY;
  function step(ts){
    const t = Math.min(1, (ts - start)/duration);
    const eased = 1 - Math.pow(1-t,3);
    rotY = from + (targetDeg - from) * eased;
    applyRotation();
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* open project mapped to face(slot) */
function openFaceProject(faceEl){
  const map = { front:0, right:1, back:2, left:3, top:4, bottom:5 };
  const slot = faceEl.dataset.slot;
  const i = map[slot] % projects.length;
  const p = projects[i];
  if(p && p.url) window.open(p.url,'_blank');
}

/* inertia loop */
let last = performance.now();
function loop(now){
  const dt = (now - last)/1000; last = now;
  if(!isDown && Math.abs(angVel) > 0.0005){
    rotY += angVel;
    angVel *= Math.pow(0.90, dt*60);
    applyRotation();
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* bindings & lifecycle */
window.addEventListener('resize', ()=>{ layoutUpdate(); });
window.addEventListener('load', ()=>{ layoutUpdate(); applyRotation(); setTimeout(layoutUpdate,90); });

/* face click open */
Array.from(document.querySelectorAll('.face')).forEach(f=>{
  f.addEventListener('click', ()=> openFaceProject(f));
});

/* initial */
applyRotation();
layoutUpdate();
</script>
</body>
</html>
