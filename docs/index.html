<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rotating Cube Portfolio</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f1724;color:#e6eef6;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
    #container{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    canvas{display:block}
    .hint{
      position:fixed;left:16px;bottom:16px;background:rgba(10,12,20,0.6);color:#cfe7ff;padding:10px 12px;border-radius:8px;font-size:13px
    }
  </style>
</head>
<body>
<div id="container"></div>
<div class="hint">Drag left/right to spin • Click face to open project • Esc to stop spin</div>

<script type="module">
// -- Dependencies: Three.js from CDN --
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/controls/OrbitControls.js';

const container = document.getElementById('container');
const width = Math.min(window.innerWidth, 1100);
const height = Math.min(window.innerHeight, 760);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x071028, 0.035);

const camera = new THREE.PerspectiveCamera(38, width / height, 0.1, 2000);
camera.position.set(0, 0.9, 3.6);

// lighting
const hemi = new THREE.HemisphereLight(0xb9d8ff, 0x080820, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(5, 7, 2);
scene.add(dir);

// ground subtle
const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshBasicMaterial({color:0x08101b,opacity:0.3,transparent:true}));
ground.rotation.x = -Math.PI/2;
ground.position.y = -1.35;
scene.add(ground);

// Axle visual
const axisMat = new THREE.MeshStandardMaterial({ color: 0x909faf, metalness:0.8, roughness:0.25 });
const rod = new THREE.CylinderGeometry(0.035,0.035,6,16);
const rodMesh = new THREE.Mesh(rod, axisMat);
rodMesh.rotation.z = Math.PI/2; // horizontal rod through cube top/bottom
rodMesh.position.y = 0.15;
scene.add(rodMesh);

// Project data: will try to fetch projects.json, otherwise fallback:
let projects = [
  { title: "Minesweeper", snippet: "Interactive minesweeper rebuild", url: "/PolyWeave-Mines/", img: "" },
  { title: "Project 2", snippet: "Placeholder 2", url: "#", img: "" },
  { title: "Project 3", snippet: "Placeholder 3", url: "#", img: "" },
  { title: "Project 4", snippet: "Placeholder 4", url: "#", img: "" },
  { title: "Project 5", snippet: "Placeholder 5", url: "#", img: "" }
];

async function loadProjects() {
  try {
    const res = await fetch('/projects.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('no projects.json');
    const data = await res.json();
    if (Array.isArray(data) && data.length) projects = data;
  } catch (e) {
    // fallback to built-in projects
    console.warn('projects.json not found or invalid — using fallback projects');
  }
}
await loadProjects();

// Create canvases as textures for 6 faces: order is +X, -X, +Y, -Y, +Z, -Z in BoxGeometry default.
// We'll treat front (=+Z) as welcome (face index 4), and the four horizontal sides as cycling carousel: +X (right), -Z (back), -X (left), +Z (front).
const faceCanvases = [];
const faceTextures = [];
for (let i=0;i<6;i++){
  const c = document.createElement('canvas');
  c.width = 1024; c.height = 1024;
  faceCanvases.push(c);
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  faceTextures.push(tex);
}

// Utility to draw UI into a canvas for a face
function renderFaceCanvas(canvas, title, snippet, indexLabel, accent="#79c9ff") {
  const ctx = canvas.getContext('2d');
  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#071425';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // subtle vignette
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, 'rgba(255,255,255,0.02)');
  g.addColorStop(1, 'rgba(0,0,0,0.12)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // accent panel
  ctx.fillStyle = accent;
  ctx.globalAlpha = 0.06;
  ctx.fillRect(56, 56, canvas.width-112, canvas.height-112);
  ctx.globalAlpha = 1;

  // Title
  ctx.fillStyle = '#e6eef6';
  ctx.font = 'bold 68px Inter, ui-sans-serif, system-ui';
  ctx.textAlign = 'left';
  wrapText(ctx, title, 120, 260, canvas.width-240, 72);

  // snippet
  ctx.fillStyle = '#b9d7ee';
  ctx.font = 'normal 36px Inter, ui-sans-serif';
  wrapText(ctx, snippet, 120, 420, canvas.width-240, 46);

  // index label bottom-right
  ctx.fillStyle = '#90bfe0';
  ctx.font = '600 24px Inter, ui-sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(indexLabel, canvas.width - 120, canvas.height - 80);

  // small mock thumbnail top-right
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(canvas.width-360, 120, 240, 160);
  ctx.strokeStyle = '#18364a';
  ctx.lineWidth = 6;
  ctx.strokeRect(canvas.width-360, 120, 240, 160);
}
function wrapText(ctx, text, x, y, maxWidth, lineHeight){
  const words = text.split(' ');
  let line = '';
  let yy = y;
  for (let n=0;n<words.length;n++){
    const test = line + words[n] + ' ';
    const metrics = ctx.measureText(test);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0){
      ctx.fillText(line, x, yy);
      line = words[n] + ' ';
      yy += lineHeight;
    } else {
      line = test;
    }
  }
  ctx.fillText(line, x, yy);
}

// Initial face content: index mapping function
// We'll maintain a rotating base index so faces reflect projects[(base + faceSlot) % projects.length]
let baseIndex = 0; // which project is at the "front" slot's logical 0
// faceSlots for the four horizontal faces in order: right(+X), back(-Z), left(-X), front(+Z)
const horizontalSlots = [0,1,2,3]; // logical slots

function updateAllFaceCanvases() {
  // We'll put welcome on +Y (top) to be obvious on initial view front-on.
  // But user asked front should be welcome; to match that, we will set front (+Z) to welcome initially (index 0).
  // We'll treat projects[0] as Minesweeper and ensure it's shown at front on load.
  // Assign horizontal sides from baseIndex.. baseIndex+3
  const len = projects.length;
  // ensure baseIndex 0 means front shows projects[0]
  // map slots: front is slot 3 (face index 4 in geometry mapping), right slot 0 (+X face-> index 0), back slot1, left slot2, front slot3
  // We'll compute projectIndex for each slot:
  for (let slot=0; slot<4; slot++){
    const projIndex = (baseIndex + slot) % len;
    const p = projects[projIndex] || { title: String(projIndex+1), snippet: "Placeholder", url:"#"};
    const canvas = faceCanvases[ slotFaceToGeometryFace(slot) ];
    renderFaceCanvas(canvas, p.title, p.snippet, `#${projIndex+1}`);
    faceTextures[ slotFaceToGeometryFace(slot) ].needsUpdate = true;
  }

  // Welcome face: we want the "welcome" face to be seen initially on the front face location.
  // We'll draw "Welcome" onto the same front face if desired. But user wanted minesweeper on first face.
  // So ensure front slot (slot==3) shows Minesweeper (we already set slot 3 = baseIndex+3). To make baseIndex such that front shows project 0, set baseIndex = (len - 3) % len on load.
}
function slotFaceToGeometryFace(slot){
  // map our horizontal slot index to BoxGeometry material index:
  // BoxGeometry materials order: +X:0, -X:1, +Y:2, -Y:3, +Z:4, -Z:5
  // We'll use slots: 0->+X(material 0), 1->-Z(material 5), 2->-X(material 1), 3->+Z(material 4)
  if (slot === 0) return 0;
  if (slot === 1) return 5;
  if (slot === 2) return 1;
  if (slot === 3) return 4;
  return 4;
}

// Fill the remaining faces: top (+Y -> 2) and bottom (-Y -> 3)
function renderWelcomeFace() {
  const canvas = faceCanvases[2];
  const title = "Welcome to my site";
  const snippet = "Drag left or right to explore projects. Click a face to open it.";
  renderFaceCanvas(canvas, title, snippet, "welcome", "#b6ffd9");
  faceTextures[2].needsUpdate = true;

  const canvasB = faceCanvases[3];
  renderFaceCanvas(canvasB, "More projects", "This face is decorative; the four sides are the carousel.", "info", "#ffc9b6");
  faceTextures[3].needsUpdate = true;
}

// Build cube with 6 materials
const materials = faceTextures.map(t => new THREE.MeshStandardMaterial({ map: t, metalness: 0.25, roughness: 0.6 }));
const box = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.6, 1.6), materials);

// small bevel by applying slight scale on edges via normal map not necessary — keep simple
scene.add(box);

// place cube so rod visually goes through top (we put rod through center horizontally)
box.position.y = 0.1;

// initialize baseIndex so front shows projects[0] (Minesweeper)
function initBaseIndex() {
  // front is slot 3. We need baseIndex + 3 ≡ 0 (mod len) -> baseIndex ≡ (len - 3)
  const len = projects.length;
  baseIndex = ((len - 3) % len + len) % len;
}
initBaseIndex();
renderWelcomeFace();
updateAllFaceCanvases();

// rotation state & controls
let isDragging = false;
let lastX = 0;
let velocity = 0;
let autoSpin = false;

const dragSensitivity = 0.0055; // tweak for feel

// restrict rotation to Y axis only
let quaternionTarget = new THREE.Quaternion().copy(box.quaternion);

// mouse/touch handlers
function startDrag(clientX) {
  isDragging = true;
  lastX = clientX;
  velocity = 0;
  autoSpin = false;
}
function moveDrag(clientX) {
  if (!isDragging) return;
  const dx = clientX - lastX;
  lastX = clientX;
  const deltaAngle = dx * dragSensitivity;
  // apply rotation around world Y
  const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), deltaAngle);
  box.quaternion.premultiply(q);
  velocity = deltaAngle;
}
function endDrag() {
  isDragging = false;
  // allow inertial spin
  if (Math.abs(velocity) > 0.001) {
    autoSpin = true;
  }
}

// pointer
renderer.domElement.addEventListener('pointerdown', e => {
  renderer.domElement.setPointerCapture(e.pointerId);
  startDrag(e.clientX);
});
renderer.domElement.addEventListener('pointermove', e => {
  moveDrag(e.clientX);
});
renderer.domElement.addEventListener('pointerup', e => {
  renderer.domElement.releasePointerCapture(e.pointerId);
  endDrag();
});
renderer.domElement.addEventListener('pointerleave', e => {
  endDrag();
});

// wheel for coarse snaps
renderer.domElement.addEventListener('wheel', e => {
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  // rotate by 90deg chunk
  const angle = delta * 0.52;
  const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angle);
  box.quaternion.premultiply(q);
});

// keyboard
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') {
    const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), 0.35);
    box.quaternion.premultiply(q);
  } else if (e.key === 'ArrowRight') {
    const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -0.35);
    box.quaternion.premultiply(q);
  } else if (e.key === 'Escape') {
    autoSpin = false; velocity = 0;
  }
});

// Raycast for clicks on faces
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('click', (ev) => {
  // ignore click while dragging
  if (isDragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObject(box, true);
  if (hits.length) {
    const faceIndex = hits[0].face.materialIndex;
    // map materialIndex to slot and compute corresponding project index
    const slot = geometryFaceToSlot(faceIndex);
    if (slot === null) {
      // clicked top/bottom: do nothing
      return;
    }
    const projectIndex = (baseIndex + slot) % projects.length;
    const p = projects[projectIndex];
    if (p && p.url) {
      // open in new tab (same-origin relative links will work)
      window.open(p.url, '_blank');
    }
  }
});

function geometryFaceToSlot(matIndex) {
  // inverse of slotFaceToGeometryFace
  if (matIndex === 0) return 0;
  if (matIndex === 5) return 1;
  if (matIndex === 1) return 2;
  if (matIndex === 4) return 3;
  return null;
}

// Main animation loop
let lastTime = performance.now();
function animate(time){
  requestAnimationFrame(animate);
  const dt = (time - lastTime) / 1000;
  lastTime = time;

  if (autoSpin) {
    // apply inertial damping
    velocity *= 0.985;
    const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), velocity);
    box.quaternion.premultiply(q);
    if (Math.abs(velocity) < 0.0005) {
      autoSpin = false;
      velocity = 0;
    }
  }

  // keep the cube upright, zero out X and Z rotation — ensure only Y rotation remains
  const euler = new THREE.Euler().setFromQuaternion(box.quaternion, 'YXZ');
  const fixedQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, euler.y, 0));
  box.quaternion.slerp(fixedQuat, 0.15);

  // detect when a quarter-turn passes to update baseIndex
  // compute approximate yaw angle from quaternion
  const yaw = (new THREE.Euler().setFromQuaternion(box.quaternion, 'YXZ')).y; // radians
  // Normalize to 0..2PI
  let normYaw = yaw % (Math.PI*2);
  if (normYaw < 0) normYaw += Math.PI*2;
  // Determine which of the four slots is in the front-facing approx (front slot=3)
  // We'll compute front-facing slot index by angle mapping:
  // slot 3 (front) corresponds to yaw ~ 0
  // slot 0 (right) corresponds to yaw ~ -Math.PI/2 (or 3*Math.PI/2)
  // slot 1 (back) ~ Math.PI
  // slot 2 (left) ~ Math.PI/2
  // Map angle to nearest slot:
  const slotAngleCenters = [
    (3*Math.PI/2) % (2*Math.PI), // right (slot 0)
    Math.PI,                     // back (slot 1)
    Math.PI/2,                   // left (slot 2)
    0                            // front (slot 3)
  ];
  // find nearest center
  let minDiff = Infinity, nearestSlot = 0;
  for (let s=0;s<4;s++){
    let diff = Math.abs(angleDiff(normYaw, slotAngleCenters[s]));
    if (diff < minDiff) { minDiff = diff; nearestSlot = s; }
  }
  // We want 'nearestSlot' to correspond to the physical slot that currently sits at front.
  // Compute targetBaseIndex so that project at front (slot 3) equals current project index:
  // If nearestSlot is s, then the logical front slot (3) corresponds to project index baseIndex + 3,
  // but if the cube rotated so that slot s is facing front, the displayed front slot is s.
  // To detect transitions, we'll track a lastFrontSlot and when it changes, we shift baseIndex accordingly.

  if (typeof animate.lastFrontSlot === 'undefined') animate.lastFrontSlot = 3;
  const frontSlot = nearestSlot;
  if (frontSlot !== animate.lastFrontSlot) {
    // user rotated so a different slot is now front-facing.
    // We need to update baseIndex so that the sequence of projects scrolls in the direction user rotated.
    // Determine rotation direction: +y increase means leftwards spin? Use difference between previous and current yaw.
    const prevYaw = animate.prevYaw ?? normYaw;
    const dYaw = smallestSignedAngleDifference(normYaw, prevYaw);
    // If rotation was negative, user spun right-to-left (projects move forward).
    const dir = dYaw < 0 ? 1 : -1;
    // Update baseIndex by dir (positive => next project)
    baseIndex = (baseIndex + dir + projects.length) % projects.length;
    updateAllFaceCanvases();
    animate.lastFrontSlot = frontSlot;
  }
  animate.prevYaw = normYaw;

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// Helpers
function angleDiff(a,b){ // absolute difference normalized
  let d = Math.abs(a-b) % (2*Math.PI);
  if (d > Math.PI) d = 2*Math.PI - d;
  return d;
}
function smallestSignedAngleDifference(a,b){
  let d = (a - b) % (2*Math.PI);
  if (d < -Math.PI) d += 2*Math.PI;
  if (d > Math.PI) d -= 2*Math.PI;
  return d;
}

// initially draw canvases for placeholders
function drawInitialCanvases() {
  // assign the 4 horizontal slots based on baseIndex -> so front shows projects[0]
  const len = projects.length;
  for (let slot=0; slot<4; slot++){
    const projIndex = (baseIndex + slot) % len;
    const p = projects[projIndex] || { title: `Project ${projIndex+1}`, snippet: "Placeholder", url:"#"};
    const geomFace = slotFaceToGeometryFace(slot);
    renderFaceCanvas(faceCanvases[geomFace], p.title, p.snippet, `#${projIndex+1}`);
    faceTextures[geomFace].needsUpdate = true;
  }
  renderWelcomeFace();
}
drawInitialCanvases();

// resize
window.addEventListener('resize', () => {
  const w = Math.min(window.innerWidth, 1100);
  const h = Math.min(window.innerHeight, 760);
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});

// Utility to open project by index (used if you add UI later)
function openProjectBySlot(slot) {
  const idx = (baseIndex + slot) % projects.length;
  const p = projects[idx];
  if (p && p.url) window.open(p.url, '_blank');
}

</script>
</body>
</html>
