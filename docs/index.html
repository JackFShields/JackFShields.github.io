<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>THE CUBE</title>
  <link rel="icon" href="https://raw.githubusercontent.com/JackFShields/JackFShields.github.io/refs/heads/main/cube.png" type="image/x-icon" />
  <style>
    :root{
      --bg:#071425;
      --panel-grad:linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.01));
      --panel-solid:rgba(10,18,28,0.92);
      --border:rgba(255,255,255,0.08);
      --text:#e6eef6;
      --muted:rgba(190,215,240,0.7);

      --cube-size:200px;
      --gap:14px;
      --col-gap:220px;       /* gap between left column and iframe column */
      --left-col-width:240px;
      --viewport-padding-y:2vh;
      --viewport-padding-x:2vw;
      --top-row-height:calc(var(--cube-size) + 16px);
      --corner-radius:14px;
      --scene-perspective:1200px;

      --iframe-base-scale:0.82; /* base visual scale applied to iframe content */
      --iframe-auto-factor:1;
      --iframe-visual-scale:calc(var(--iframe-base-scale) * var(--iframe-auto-factor));
    }

    html,body{height:100%;margin:0}
    *{box-sizing:border-box}
    body{background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;-webkit-font-smoothing:antialiased}
    .viewport{width:100vw;height:100vh;padding:var(--viewport-padding-y) var(--viewport-padding-x)}
    .layout{display:grid;grid-template-columns:var(--left-col-width) 1fr;grid-template-rows:var(--top-row-height) 1fr;column-gap:var(--col-gap);row-gap:var(--gap);width:100%;height:100%;align-items:start}
    .panel{background:var(--panel-grad);background-color:var(--panel-solid);border:1px solid var(--border);border-radius:var(--corner-radius);padding:16px;box-shadow:0 10px 36px rgba(0,0,0,0.36);position:relative;overflow:visible}
    .cube-cell{grid-column:1/2;grid-row:1/2;display:flex;align-items:center;justify-content:flex-start;padding:8px;background:transparent}
    .cube-wrap{width:var(--cube-size);height:var(--cube-size);max-height:calc(var(--top-row-height)-8px);overflow:hidden;position:relative;margin:0;z-index:5;user-select:none;touch-action:none}
    .scene{width:100%;height:100%;perspective:var(--scene-perspective)}
    .cube{width:100%;height:100%;transform-style:preserve-3d;transform:translateZ(calc(var(--cube-size)/-2)) rotateX(-10deg) rotateY(0deg);transition:transform .08s linear}
    .face{position:absolute;left:0;top:0;width:100%;height:100%;border-radius:12px;background:var(--panel-grad);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;box-shadow:0 10px 36px rgba(0,0,0,0.6);backface-visibility:hidden;cursor:pointer}
    .front{transform:rotateY(0deg) translateZ(calc(var(--cube-size)/2))}
    .right{transform:rotateY(90deg) translateZ(calc(var(--cube-size)/2))}
    .back{transform:rotateY(180deg) translateZ(calc(var(--cube-size)/2))}
    .left{transform:rotateY(270deg) translateZ(calc(var(--cube-size)/2))}
    .top{transform:rotateX(90deg) translateZ(calc(var(--cube-size)/2))}
    .bottom{transform:rotateX(-90deg) translateZ(calc(var(--cube-size)/2))}
    .title{grid-column:2/3;grid-row:1/2;display:flex;flex-direction:column;justify-content:center;min-height:var(--top-row-height);padding:14px 20px}
    .title h1{font-size:20px;margin-bottom:6px}
    .title p{color:var(--muted);margin-top:4px;font-size:13px}
    .description{grid-column:1/2;grid-row:2/3;height:100%;overflow:auto;padding:18px}
    .description p{color:var(--muted);line-height:1.45}

    /* image panel and iframe wrapper */
    .panel.image{padding:0;overflow:hidden}
    .image{grid-column:2/3;grid-row:2/3;position:relative;width:100%;height:100%;overflow:hidden;border-radius:var(--corner-radius);background:transparent}
    .iframe-zoom-wrap{position:absolute;inset:0;overflow:hidden;display:none;pointer-events:auto}
    .iframe-scale{position:absolute;left:0;top:0;transform-origin:0 0;transform:scale(var(--iframe-visual-scale));width:calc(100% / var(--iframe-visual-scale));height:calc(100% / var(--iframe-visual-scale));will-change:transform}
    .image iframe{position:absolute;inset:0;width:100%;height:100%;border:0;border-radius:calc(var(--corner-radius));display:block;background:#071425}
    .image .fallback{color:var(--muted);position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:12px}

    @media(max-width:980px){
      .layout{grid-template-columns:1fr;grid-template-rows:auto auto 1fr 36vh;column-gap:16px;row-gap:12px;padding:2vh 4vw}
      .cube-cell{grid-column:1;grid-row:1;justify-content:center}
      .title{grid-column:1;grid-row:2}
      .description{grid-column:1;grid-row:3;max-height:36vh}
      .image{grid-column:1;grid-row:4;height:36vh}
      .iframe-zoom-wrap{inset:0}
      .iframe-scale{width:100%;height:100%;transform:scale(var(--iframe-visual-scale))}
      .image iframe{position:absolute;inset:0;height:100%;width:100%}
      .cube-wrap{margin:8px auto;max-height:none}
    }
  </style>
</head>
<body>
  <div class="viewport">
    <div class="layout" id="layout">

      <div class="cube-cell">
        <div class="cube-wrap" id="cubeWrap">
          <div class="scene" id="scene">
            <div class="cube" id="cube" role="application" aria-label="cube">
              <div class="face front" data-slot="front"></div>
              <div class="face right" data-slot="right"></div>
              <div class="face back" data-slot="back"></div>
              <div class="face left" data-slot="left"></div>
              <div class="face top" data-slot="top"></div>
              <div class="face bottom" data-slot="bottom"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel title" id="titlePanel">
        <h1 id="projTitle">Unfinished project</h1>
        <p id="projSubtitle"></p>
      </div>

      <div class="panel description" id="descPanel">
        <p id="projDesc"></p>
      </div>

      <div class="panel image" id="imagePanel">
        <div class="image" id="imageContainer">
          <div class="fallback">Preview will appear here</div>
          <div id="iframeZoomWrap" class="iframe-zoom-wrap"></div>
        </div>
      </div>

    </div>
  </div>

  <script>
    // rotation/cube logic (unchanged)
    let projectsData = [];
    const scene = document.getElementById('scene');
    const cube = document.getElementById('cube');
    const imageContainer = document.getElementById('imageContainer');
    const iframeZoomWrap = document.getElementById('iframeZoomWrap');
    const imagePanel = document.getElementById('imagePanel');

    let rotY=0, isDown=false, startX=0, startRot=0, startT=0, angVel=0;
    const SENS=0.35, CLICK_MOVE_THRESHOLD=6, CLICK_TIME_THRESHOLD=300;
    let faceIndices={front:0,right:3,back:2,left:1,top:-1,bottom:-1};
    let projectCounter=0, lastBoundary=null, totalRotation=0, prevRotation=0;

    scene.addEventListener('pointerdown', e=>{ isDown=true; startX=e.clientX; startRot=rotY; startT=performance.now(); angVel=0; try{ scene.setPointerCapture(e.pointerId); }catch(_){} });
    scene.addEventListener('pointermove', e=>{ if(!isDown) return; const dx=e.clientX-startX; const target=startRot + dx * SENS; angVel = target - rotY; rotY = target; totalRotation = rotY; applyRotation(); });
    scene.addEventListener('pointerup', e=>{ try{ scene.releasePointerCapture(e.pointerId); }catch(_){} const dt=performance.now()-startT; const moved=Math.abs(e.clientX-startX); const isClick = moved<=CLICK_MOVE_THRESHOLD && dt<=CLICK_TIME_THRESHOLD; isDown=false; angVel = Math.max(-20, Math.min(20, angVel)); if(isClick){ const el=document.elementFromPoint(e.clientX,e.clientY); const face = el && el.closest && el.closest('.face'); if(face){ const slot = face.dataset.slot; const idx = faceIndices[slot] ?? 0; const p = projectsData.find(x=>x.value===idx); if(p && p.project_link){ const href = p.project_link.startsWith('http')?p.project_link:`https://${p.project_link}`; window.open(href,'_blank'); } } } });

    function applyRotation(){
      if(lastBoundary===null) lastBoundary = Math.floor(rotY/90);
      cube.style.transform = `translateZ(calc(var(--cube-size)/-2)) rotateX(-10deg) rotateY(${rotY}deg)`;
      handleThresholds(prevRotation, totalRotation);
      prevRotation = totalRotation;
      updatePanelsFromVisibleFace();
      refreshFaceContent();
      switchIframeToVisibleFace();
    }
    function normalizeDeg(d){ let v=d%360; if(v<0) v+=360; return v; }
    function mostVisibleFace(){ const norm = normalizeDeg(rotY); if(norm>=45 && norm<135) return 'left'; if(norm>=135 && norm<225) return 'back'; if(norm>=225 && norm<315) return 'right'; return 'front'; }
    function handleThresholds(prevTotal,newTotal){ if(lastBoundary===null) lastBoundary=Math.floor(newTotal/90); const currentBoundary=Math.floor(newTotal/90); if(currentBoundary!==lastBoundary){ const direction = currentBoundary>lastBoundary?1:-1; projectCounter = Math.max(0, projectCounter + direction); lastBoundary=currentBoundary; const visibleFace = mostVisibleFace(); const hiddenMap = { front:'back', left:'right', back:'front', right:'left' }; const hiddenFace = hiddenMap[visibleFace]; faceIndices[hiddenFace] = projectCounter; } }

    function refreshFaceContent(){ ['front','right','back','left','top','bottom'].forEach(slot=>{ const el=document.querySelector(`.face.${slot}`); if(!el) return; el.innerHTML=''; }); updateFaceImages(); }
    function updateFaceImages(){ ['front','right','back','left','top','bottom'].forEach(slot=>{ const el=document.querySelector(`.face.${slot}`); if(!el) return; const idx = faceIndices[slot] ?? 0; const project = projectsData.find(p=>p.value===idx); el.style.backgroundImage=''; el.style.cursor='default'; if(el._removeHandlers){ el._removeHandlers(); el._removeHandlers=null; } if(project && project.face_of_cube_image_link){ el.style.backgroundImage=`url(${project.face_of_cube_image_link})`; el.style.backgroundSize='cover'; el.style.backgroundPosition='center'; el.style.cursor='pointer'; let downX=0, downY=0, moved=false, threshold=6; const onDown=e=>{ moved=false; downX=e.clientX; downY=e.clientY }; const onMove=e=>{ if(Math.abs(e.clientX-downX)>threshold||Math.abs(e.clientY-downY)>threshold) moved=true }; const onUp=e=>{ if(!moved){ const href = project.project_link.startsWith('http')?project.project_link:`https://${project.project_link}`; window.open(href,'_blank'); } }; el.addEventListener('pointerdown', onDown, {passive:true}); el.addEventListener('pointermove', onMove, {passive:true}); el.addEventListener('pointerup', onUp, {passive:true}); el._removeHandlers = ()=>{ el.removeEventListener('pointerdown', onDown); el.removeEventListener('pointermove', onMove); el.removeEventListener('pointerup', onUp); }; } }); }

    function updatePanelsFromVisibleFace(){ const slot = mostVisibleFace(); const currentVisibleValue = faceIndices[slot] ?? 0; let project = projectsData.find(p=>p.value===currentVisibleValue); if(!project && projectsData.length>0) project = projectsData[Math.abs(projectCounter)%projectsData.length] || projectsData[0]; if(project){ document.getElementById('projTitle').textContent = project.project_name || 'Unnamed project'; document.getElementById('projSubtitle').innerHTML = project.project_link ? `<a href="${project.project_link.startsWith('http')?project.project_link:'https://'+project.project_link}" target="_blank" style="color:inherit;text-decoration:underline">${project.project_link}</a>` : ''; document.getElementById('projDesc').textContent = project.description || ''; } else { document.getElementById('projTitle').textContent='Unfinished project'; document.getElementById('projSubtitle').textContent=''; document.getElementById('projDesc').textContent=''; } }

    // ---------- iframe logic: same-origin srcdoc injection OR cross-origin wrapper + reflow nudges ----------
    let persistentIframe = null;
    let usingWrapperScale = false;

    function makeAbsoluteUrl(raw){ if(!raw || typeof raw !== 'string') return null; const t = raw.trim(); if(t==='') return null; if(/^https?:\/\//i.test(t)) return t; return 'https://' + t; }

    function ensurePersistentIframe(){ if(persistentIframe && imageContainer.contains(persistentIframe)) return persistentIframe; const wrap = iframeZoomWrap; imageContainer.innerHTML=''; imageContainer.appendChild(wrap); persistentIframe = document.createElement('iframe'); persistentIframe.setAttribute('title','project-preview'); persistentIframe.setAttribute('sandbox','allow-same-origin allow-scripts allow-forms'); persistentIframe.style.border='0'; persistentIframe.style.width='100%'; persistentIframe.style.height='100%'; persistentIframe.style.display='block'; persistentIframe.style.borderRadius='var(--corner-radius)'; imageContainer.appendChild(persistentIframe); return persistentIframe; }

    // SAME-ORIGIN: fetch HTML, inject viewport/meta/zoom BEFORE scripts run, write via srcdoc
    async function loadSameOriginIntoIframe(url, iframeEl, visualScale){
      try{
        const resp = await fetch(url, {cache:'no-store', credentials:'omit'});
        if(!resp.ok) throw new Error('fetch failed');
        let html = await resp.text();

        const containerRect = imageContainer.getBoundingClientRect();
        const containerW = Math.max(320, Math.round(containerRect.width));
        const desiredViewportWidth = Math.max(320, Math.round(containerW / visualScale));

        const headInsert = `
<meta name="viewport" content="width=${desiredViewportWidth}, initial-scale=1">
<style id="injected-zoom"> html, body { zoom: ${visualScale}; -moz-transform: scale(${visualScale}); -moz-transform-origin: 0 0; width: calc(100% / ${visualScale}); height: calc(100% / ${visualScale}); } </style>
<script id="injected-resize">window.addEventListener('load', ()=>{ setTimeout(()=>{ window.dispatchEvent(new Event('resize')); },40); });</script>
`;

        if(/\<head[\s\S]*?\>/i.test(html)){
          html = html.replace(/\<head([\s\S]*?)\>/i, match => match + headInsert);
        } else if(/\<html[\s\S]*?\>/i.test(html)){
          html = html.replace(/\<html([\s\S]*?)\>/i, match => match + '<head>' + headInsert + '</head>');
        } else {
          html = '<head>' + headInsert + '</head>' + html;
        }

        iframeEl.srcdoc = html;
        iframeEl.removeAttribute('src');
        return true;
      }catch(e){
        return false;
      }
    }

    // INJECTION fallback (attempt to set viewport/meta + zoom when same-origin and iframe.document accessible)
    async function injectViewportAndZoom(iframeEl, visualScale){
      try{
        const win = iframeEl.contentWindow;
        if(!win) throw new Error('no contentWindow');
        const doc = iframeEl.contentDocument || win.document;
        if(!doc) throw new Error('no document');

        const containerRect = imageContainer.getBoundingClientRect();
        const containerW = Math.max(320, Math.round(containerRect.width));
        const desiredViewportWidth = Math.max(320, Math.round(containerW / visualScale));

        let meta = doc.querySelector('meta[name="viewport"]');
        if(!meta){
          meta = doc.createElement('meta');
          meta.name = 'viewport';
          if(doc.head) doc.head.appendChild(meta);
          else if(doc.documentElement) { const head = doc.createElement('head'); doc.documentElement.insertBefore(head, doc.body || null); head.appendChild(meta); }
        }
        meta.setAttribute('content', `width=${desiredViewportWidth}, initial-scale=1`);

        doc.documentElement.style.setProperty('zoom', String(visualScale));
        if(doc.body){ doc.body.style.transform = `scale(${visualScale})`; doc.body.style.transformOrigin = '0 0'; doc.body.style.width = `calc(100% / ${visualScale})`; doc.body.style.height = `calc(100% / ${visualScale})`; doc.body.style.overflow = 'auto'; }
        doc.documentElement.style.overflow = 'auto';

        return true;
      }catch(e){
        return false;
      }
    }

    // WRAPPER (cross-origin) build
    function ensureWrapperScaleExists(scale){
      usingWrapperScale = true;
      iframeZoomWrap.style.display = 'block';
      iframeZoomWrap.innerHTML = '';
      const scaleEl = document.createElement('div');
      scaleEl.className = 'iframe-scale';
      scaleEl.style.setProperty('--iframe-visual-scale', String(scale));
      const ifr = document.createElement('iframe');
      ifr.setAttribute('title','project-preview');
      ifr.setAttribute('sandbox','allow-same-origin allow-scripts allow-forms');
      ifr.style.border = '0';
      ifr.style.width = `calc(100% / ${scale})`;
      ifr.style.height = `calc(100% / ${scale})`;
      ifr.style.display = 'block';
      scaleEl.appendChild(ifr);
      iframeZoomWrap.appendChild(scaleEl);
      return ifr;
    }

    function removeWrapperScale(){ usingWrapperScale = false; iframeZoomWrap.style.display = 'none'; iframeZoomWrap.innerHTML = ''; }

    // tiny oscillation nudges to encourage cross-origin pages to reflow
    function nudgeCrossOriginIframeForReflow(wrapperIframeEl, attempts = 5){
      const origScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--iframe-visual-scale')) || 0.88;
      let i = 0;
      function step(){
        if(i >= attempts) return;
        const up = origScale * (1 + 0.006 * (i % 2 ? 1 : -1));
        const down = origScale;
        const scaleEl = wrapperIframeEl.closest('.iframe-scale');
        if(scaleEl){
          scaleEl.style.transform = `scale(${up})`;
          wrapperIframeEl.style.width = `calc(100% / ${up})`;
          wrapperIframeEl.style.height = `calc(100% / ${up})`;
        }
        setTimeout(()=>{
          if(scaleEl){
            scaleEl.style.transform = `scale(${down})`;
            wrapperIframeEl.style.width = `calc(100% / ${down})`;
            wrapperIframeEl.style.height = `calc(100% / ${down})`;
          }
          i++;
          setTimeout(step, 120);
        }, 90);
      }
      step();
    }

    // compute auto factor (target page width approach)
    function recomputeAutoScaleFactor(){
      try{
        const style = getComputedStyle(document.documentElement);
        const base = parseFloat(style.getPropertyValue('--iframe-base-scale')) || 0.82;
        const leftWidth = parseFloat(style.getPropertyValue('--left-col-width')) || 240;
        const colGap = parseFloat(style.getPropertyValue('--col-gap')) || 220;
        const padX = parseFloat(style.getPropertyValue('--viewport-padding-x')) || 0;
        const viewportW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const available = Math.max(320, viewportW - leftWidth - colGap - (padX*2));
        const targetPageWidth = 1200;
        let desiredVisual = Math.min(1, Math.max(0.55, available / targetPageWidth));
        let autoFactor = desiredVisual / base;
        autoFactor = Math.max(0.6, Math.min(1.6, autoFactor));
        document.documentElement.style.setProperty('--iframe-auto-factor', String(autoFactor));
        return base * autoFactor;
      }catch(e){
        return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--iframe-base-scale')) || 0.82;
      }
    }

    // main selection that prefers same-origin fetch+srcdoc, then injection, then wrapper fallback
    async function switchIframeToVisibleFace(){
      if(projectsData.length === 0) return;
      const slot = mostVisibleFace();
      const currentVisibleValue = faceIndices[slot] ?? 0;
      let project = projectsData.find(p=>p.value === currentVisibleValue);
      if(!project && projectsData.length > 0) project = projectsData[Math.abs(projectCounter) % projectsData.length] || projectsData[0];
      if(!project) return;

      const raw = project.iframe_link || project.image_link || '';
      const url = makeAbsoluteUrl(raw);
      if(!url){
        if(persistentIframe && imageContainer.contains(persistentIframe)){ imageContainer.removeChild(persistentIframe); persistentIframe = null; }
        removeWrapperScale();
        imageContainer.innerHTML = '<div class="fallback">No iframe_link provided for this project</div>';
        return;
      }

      const appliedScale = recomputeAutoScaleFactor();

      // try to load same-origin via fetch+srcdoc (best) â€” this will fail if remote blocks CORS
      const ifr = ensurePersistentIframe();
      if(usingWrapperScale) removeWrapperScale();

      // if iframe already points to url, still attempt injection/reload path
      const normalizeHref = u => { try{ const a=document.createElement('a'); a.href = u; return a.href.replace(/\/$/, ''); }catch(e){ return u; } };
      const nCur = normalizeHref(ifr.src || '');
      const nNew = normalizeHref(url);

      // FIRST: Attempt fetch+srcdoc (same-origin/CORS) for a clean pre-inserted head
      let fetchedOk = false;
      try{
        fetchedOk = await loadSameOriginIntoIframe(url, ifr, appliedScale);
      }catch(e){
        fetchedOk = false;
      }
      if(fetchedOk){
        removeWrapperScale();
        imagePanel.style.borderLeft = '4px solid #19a6ff';
        return;
      }

      // SECOND: if fetch failed, set src and attempt in-page injection (if same-origin accessible)
      if(nCur !== nNew){
        let loadHandled = false;
        ifr.src = url;
        setTimeout(()=>{
          if(loadHandled) return;
          const onLoad = async ()=>{
            loadHandled = true;
            const injected = await injectViewportAndZoom(ifr, appliedScale);
            if(!injected){
              // fallback to wrapper scaling (cross-origin)
              const wrapperIframe = ensureWrapperScaleExists(appliedScale);
              wrapperIframe.src = url;
              if(persistentIframe && imageContainer.contains(persistentIframe)){ imageContainer.removeChild(persistentIframe); persistentIframe = null; }
              // after wrapper iframe loads, apply nudges
              wrapperIframe.addEventListener('load', ()=>{ setTimeout(()=> nudgeCrossOriginIframeForReflow(wrapperIframe, 6), 120); }, {once:true});
            } else {
              removeWrapperScale();
            }
          };
          try{ ifr.removeEventListener('load', onLoad); }catch(e){}
          ifr.addEventListener('load', onLoad, {once:true});
          // fallback attempt after 700ms to try injection (some pages load resources slowly)
          setTimeout(async ()=>{
            if(loadHandled) return;
            const injected = await injectViewportAndZoom(ifr, appliedScale);
            if(!injected){
              const wrapperIframe = ensureWrapperScaleExists(appliedScale);
              wrapperIframe.src = url;
              if(persistentIframe && imageContainer.contains(persistentIframe)){ imageContainer.removeChild(persistentIframe); persistentIframe = null; }
              wrapperIframe.addEventListener('load', ()=>{ setTimeout(()=> nudgeCrossOriginIframeForReflow(wrapperIframe, 6), 120); }, {once:true});
            } else {
              removeWrapperScale();
            }
          }, 700);
        }, 20);
      } else {
        // already loaded; try injection and fallback to wrapper if not possible
        const injected = await injectViewportAndZoom(ifr, appliedScale);
        if(!injected){
          const wrapperIframe = ensureWrapperScaleExists(appliedScale);
          wrapperIframe.src = url;
          if(persistentIframe && imageContainer.contains(persistentIframe)){ imageContainer.removeChild(persistentIframe); persistentIframe = null; }
          wrapperIframe.addEventListener('load', ()=>{ setTimeout(()=> nudgeCrossOriginIframeForReflow(wrapperIframe, 6), 120); }, {once:true});
        } else {
          removeWrapperScale();
        }
      }

      imagePanel.style.borderLeft = '4px solid #19a6ff';
    }

    // load projects.json
    async function loadProjects(){
      try{ const r = await fetch('projects.json'); projectsData = await r.json(); }catch(e){ console.warn('projects.json not loaded', e); projectsData = []; }
    }

    // loop / inertia
    let lastFrame = performance.now();
    function loop(now){
      const dt = (now - lastFrame)/1000;
      lastFrame = now;
      if(!isDown && Math.abs(angVel) > 0.0005){
        rotY += angVel;
        angVel *= Math.pow(0.92, dt * 60);
        totalRotation = rotY;
        applyRotation();
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // init
    loadProjects().then(()=>{ refreshFaceContent(); updatePanelsFromVisibleFace(); switchIframeToVisibleFace(); });
    window.addEventListener('resize', ()=>{ recomputeAutoScaleFactor(); applyRotation(); switchIframeToVisibleFace(); });
    window.addEventListener('load', ()=>{ applyRotation(); setTimeout(()=>{ applyRotation(); switchIframeToVisibleFace(); }, 120); });

    // runtime API
    window.setVisualScale = function(scale){
      if(!scale || isNaN(scale)) return;
      document.documentElement.style.setProperty('--iframe-base-scale', String(scale));
      document.documentElement.style.setProperty('--iframe-auto-factor', '1');
      const applied = recomputeAutoScaleFactor();
      if(persistentIframe) injectViewportAndZoom(persistentIframe, applied);
      if(usingWrapperScale && iframeZoomWrap.firstElementChild){
        const scaleEl = iframeZoomWrap.firstElementChild;
        scaleEl.style.setProperty('--iframe-visual-scale', String(applied));
        const inner = scaleEl.querySelector('iframe');
        if(inner){ inner.style.width = `calc(100% / ${applied})`; inner.style.height = `calc(100% / ${applied})`; inner.addEventListener('load', ()=> setTimeout(()=> nudgeCrossOriginIframeForReflow(inner,6),120), {once:true}); }
      }
    };
  </script>
</body>
</html>
